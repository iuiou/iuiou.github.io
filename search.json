[{"title":"FFT_template","url":"/2022/07/10/FFT-template/","content":"\n## FFT\n\n快速傅里叶变换，用于在 $O(n \\log n)$ 的时间复杂度内计算数组的卷积结果。针对卷积，存在以下三种 FFT 的写法。\n\n### 普通写法\n\n普通写法的 FFT，由于全程使用浮点数计算，精度存在巨大的问题。一般参与卷积的数组中每一个数的数值不超过1000，可以保证答案完全正确。\n\n**优点：**\n\n* 常数小，不管是空间复杂度还是时间复杂度都很小。\n\n**缺点：**\n\n* 精度很差，数组中数大小大于1000基本就会出现精度问题。\n\n```c++\n//\n// Created by iuiou on 2022/7/10.\n//\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6+13;\nconst double pi = acos(-1.0);\nstruct cpx{\n    double a,b;\n    cpx(double x=0.0,double y=0.0){\n        a=x,b=y;\n    }\n    cpx operator-(const cpx&x) {\n        return cpx(a-x.a,b-x.b);\n    }\n    cpx operator+(const cpx&x) {\n        return cpx(a+x.a,b+x.b);\n    }\n    cpx operator*(const cpx&x) {\n        return cpx(x.a*a-x.b*b,a*x.b+b*x.a);\n    }\n}a[maxn<<2],b[maxn<<2];//通常为卷积长度的四倍\nvoid fft(cpx x[],int op,int len) {\n    for (int i=1,j=0;i<len-1;i++){\n        for (int s = len; j ^= s >>= 1, ~j & s;);\n        if (i < j) swap(x[i], x[j]);\n    }\n    for (int d = 0; (1 << d) < len; d++) {\n        int m = 1 << d, m2 = m << 1;\n        double o = pi / m * op;\n        cpx _w(cos(o), sin(o));\n        for (int i = 0; i < len; i += m2) {\n            cpx w(1, 0);\n            for (int j = 0; j < m; j++) {\n                cpx &A = x[i + j + m],&B = x[i + j],t = w * A;\n                A = B - t;\n                B = B + t;\n                w = w * _w;\n            }\n        }\n    }\n    if (op == -1) for (int i = 0; i < len; i++) x[i].a /= len;\n}\nvoid cal(vector<int> &mul1,vector<int> &mul2){\n    int n = (int)mul1.size();\n    int m = (int)mul2.size();\n    for(int i=0;i<n;i++) a[i].a = mul1[i];\n    for(int i=0;i<m;i++) b[i].a = mul2[i];\n    int N = 1;\n    while(N < (m+n)){\n        N <<=1;\n    }\n    for(int i=n;i<N;i++) a[i] = cpx();\n    for(int i=m;i<N;i++) b[i] = cpx();\n    fft(a,1,N);\n    fft(b,1,N);\n    for(int i=0;i<N;i++){\n        a[i] = a[i]*b[i];\n    }\n    fft(a,-1,N);\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int> cal1,cal2;\n    for(int i=0;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal1.push_back(x);\n    }\n    for(int i=0;i<=m;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal2.push_back(x);\n    }\n    cal(cal1,cal2);\n    for(int i=0;i<=n+m;i++){\n        printf(\"%d \",(int)(a[i].a+0.5));\n    }\n}\n\n```\n\n### 高模数NTT\n\n本质为快速数论变换，在模数为 `31525197391593473`ll （原根还是 3）下的情况，由于该模数达到17位，所以基本上可以使用在大部分需要卷积的场合，由于是整数运算，答案一定精准。\n\n**优点：**\n\n* 运算结果不存在精度问题，可以使用在几乎所有正常的数据范围内。\n\n**缺点：**\n\n* 涉及大量 `__int128` 的计算，所以时间复杂度常数十分巨大，一般用于数据范围在1e5级别的时候。\n\n```c++\n//\n// Created by iuiou on 2022/7/10.\n//\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6+13;\nconst ll p = 31525197391593473ll;\nll a[maxn<<2],b[maxn<<2];\nll mul(ll a,ll b){\n    return (__int128)a*(__int128)b%p;\n}\nll fpow(ll a,ll b){\n    ll ans = 1;\n    while(b){\n        if(b&1) ans = mul(ans,a);\n        a = mul(a,a);\n        b >>= 1;\n    }\n    return ans;\n}\nint ntt_n;\nll omega[maxn<<2],omega_inv[maxn<<2];\nvoid NTT_init(int n){\n    ntt_n = n;\n    ll wn = fpow(3 , (p-1)/n);\n    omega[0] = omega_inv[0] = 1;\n    for(int i=1;i<n;i++){\n        omega_inv[n - i] = omega[i] = mul(omega[i-1],wn);\n    }\n}\nvoid NTT(long long *a,int n,int tp){\n    for(int i=1,j=0,k;i<n-1;i++){\n        k = n;\n        do{\n            j^=(k>>=1);\n        }while(j<k);\n        if(i<j){\n            swap(a[i],a[j]);\n        }\n    }\n    for(int k=2,m=ntt_n/2;k<=n;k*=2,m/=2){\n        for(int i=0;i<n;i+=k){\n            for(int j=0;j<k/2;j++){\n                ll w = (tp > 0 ? omega : omega_inv)[m*j];\n                ll u = a[i+j],v = mul(w,a[i+j+k/2]);\n                a[i+j] = (u+v)%p;\n                a[i+j+k/2] = (u-v+p)%p;\n            }\n        };\n    }\n    if(tp<0){\n        ll inv = fpow(n,p-2);\n        for(int i=0;i<n;i++) a[i] = mul(a[i],inv);\n    }\n}\nvoid cal(vector<int> &mul1,vector<int> &mul2){\n    int n = (int)mul1.size();\n    int m = (int)mul2.size();\n    for(int i=0;i<n;i++) a[i] = mul1[i];\n    for(int i=0;i<m;i++) b[i] = mul2[i];\n    int N = 1;\n    while(N < (m+n)){\n        N <<=1;\n    }\n    NTT_init(N);\n    for(int i=n;i<N;i++) a[i] = 0;\n    for(int i=m;i<N;i++) b[i] = 0;\n    NTT(a,N,1);\n    NTT(b,N,1);\n    for(int i=0;i<N;i++){\n        a[i] = mul(a[i],b[i]);\n    }\n    NTT(a,N,-1);\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int> cal1,cal2;\n    for(int i=0;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal1.push_back(x);\n    }\n    for(int i=0;i<=m;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal2.push_back(x);\n    }\n    cal(cal1,cal2);\n    for(int i=0;i<=n+m;i++){\n        printf(\"%lld \",a[i]);\n    }\n}\n\n```\n\n### 拆分FFT\n\n综合了精度和时间复杂度的 `FFT`，利用了 `FFT` 在数组数值小于等于 1e3 的情况下精度几乎没有问题的性质。对于数组 $A,B$ 中每一个数 $a_i,b_i$ ，将其拆分为 $S*a_{1i} + b_{1i}$ 和 $S*a_{2i} + b_{2i}$。其中 $a_{1i} = a_i / S, b_{1i} = a_{i} \\% S$ 。$a_{2i},b_{2i}$ 与之类似。一般取 $S$ 为根号值域（$1e5 \\to 1e3, 1e4 \\to 1e2$）。\n$$\n\\begin{aligned}\n{A}*{B} = &(a_1+\\ldots+a_n)(b_1+\\ldots+b_n)\\\\\n= &(SA_1 + B_1)(SA_2+B_2)\\\\\n= & S^2A_1A_2 + S(A_1B_2+A_2B_1) + B_1B_2\n\\end{aligned}\n$$\n对于最后一行式子进行傅里叶变换即可。\n\n**优点：**\n\n* 精度高，基本不会有精度问题，时间复杂度优秀。\n\n**缺点：**\n\n* 时间复杂度比标准 FFT 高一些，空间复杂度也较高。\n\n```c++\n//\n// Created by iuiou on 2022/7/10.\n//\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6+13;\nconst double pi = acos(-1.0);\nconst int S = 5;\nstruct cpx{\n    double a,b;\n    cpx(double x=0.0,double y=0.0){\n        a=x,b=y;\n    }\n    cpx operator-(const cpx&x) {\n        return cpx(a-x.a,b-x.b);\n    }\n    cpx operator+(const cpx&x) {\n        return cpx(a+x.a,b+x.b);\n    }\n    cpx operator*(const cpx&x) {\n        return cpx(x.a*a-x.b*b,a*x.b+b*x.a);\n    }\n}a1[maxn<<2],b1[maxn<<2],a2[maxn<<2],b2[maxn<<2];\nvoid fft(cpx x[],int op,int len) {\n    for (int i=1,j=0;i<len-1;i++){\n        for (int s = len; j ^= s >>= 1, ~j & s;);\n        if (i < j) swap(x[i], x[j]);\n    }\n    for (int d = 0; (1 << d) < len; d++) {\n        int m = 1 << d, m2 = m << 1;\n        double o = pi / m * op;\n        cpx _w(cos(o), sin(o));\n        for (int i = 0; i < len; i += m2) {\n            cpx w(1, 0);\n            for (int j = 0; j < m; j++) {\n                cpx &A = x[i + j + m],&B = x[i + j],t = w * A;\n                A = B - t;\n                B = B + t;\n                w = w * _w;\n            }\n        }\n    }\n    if (op == -1) for (int i = 0; i < len; i++) x[i].a /= len;\n}\nvoid cal(vector<int> &mul1,vector<int> &mul2){\n    int n = (int)mul1.size();\n    int m = (int)mul2.size();\n    for(int i=0;i<n;i++) {\n        a1[i].a = mul1[i] / S;\n        b1[i].a = mul1[i] % S;\n    }\n    for(int i=0;i<m;i++) {\n        a2[i].a = mul2[i] / S;\n        b2[i].a = mul2[i] % S;\n    }\n    int N = 1;\n    while(N < (m+n)){\n        N <<=1;\n    }\n    for(int i=n;i<N;i++) a1[i] = b1[i] = cpx();\n    for(int i=m;i<N;i++) a2[i] = b2[i] = cpx();\n    fft(a1,1,N);\n    fft(b1,1,N);\n    fft(a2,1,N);\n    fft(b2,1,N);\n    for(int i=0;i<N;i++){\n        cpx f1 = a1[i],f2 = a2[i],f3 = b1[i],f4 = b2[i];\n        a1[i] = f1*f2;\n        a2[i] = f1*f4+f2*f3;\n        b1[i] = f3*f4;\n    }\n    fft(a1,-1,N);\n    fft(a2,-1,N);\n    fft(b1,-1,N);\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int> cal1,cal2;\n    for(int i=0;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal1.push_back(x);\n    }\n    for(int i=0;i<=m;i++){\n        int x;\n        scanf(\"%d\",&x);\n        cal2.push_back(x);\n    }\n    cal(cal1,cal2);\n    for(int i=0;i<=n+m;i++){\n        int ans = 1ll*S*S*(int)(a1[i].a + 0.5) + 1ll*S*(int)(a2[i].a + 0.5) + (int)(b1[i].a + 0.5);\n        printf(\"%d \",ans);\n    }\n}\n```\n\n","tags":["算法模板"],"categories":["算法","算法整理"]},{"title":"Cryptography reading note prefix","url":"/2022/07/08/Cryptography-reading1/","content":"\n## 序章\n\n### 系统安全性定义\n\n>  “Systems are insecure when they fail to adequately look like random junk”\n\n一个安全的系统输入输出应该无法被其他人看出任何有用的信息。\n","tags":["密码学"],"categories":["密码学","The Joy of Cryptography"]},{"title":"2018牛客网暑期ACM多校训练营(第一场)","url":"/2021/07/13/2018牛客网暑期ACM多校训练营-第一场/","content":"\n## 2018牛客网暑期ACM多校训练营(第一场)\n\n<!--more-->\n\n### J\n\n* 大致题意：给定一个数列和一些询问，每个询问询问 $[l_i,r_i]$ ，询问 $[1,l_i]\\cup [r_i,n]$ 中的数字种数。\n* tag：莫队\n* 题解：签到，莫队板子，把移区间的部分稍微改一下就好。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nstruct node{\n\tint l,r,num;\n}tt[maxn];\nint n,m;\nint cnt[maxn],bel[maxn],a[maxn],ans[maxn];\nbool cmp(node a,node b)\n{\n\treturn bel[a.l]==bel[b.l]?(bel[a.l]&1?a.r<b.r:a.r>b.r):bel[a.l]<bel[b.l]; \n }\nint now=0;\n#define add(x) now+=!cnt[x]++\n#define del(x) now-=!--cnt[x]\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tint num=(int)sqrt(1.0*n);\n\t\tnow=0;\n\t\tint x=ceil(1.0*n/num);\n\t\tfor(int i=1;i<=x;i++)\n\t\t{\n\t\t\tfor(int j=(i-1)*num+1;j<=min(n,i*num);j++)\n\t\t\t{\n\t\t\t\tbel[j]=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++) cnt[i]=0,scanf(\"%d\",&a[i]);\n\t\tint l,r;\n\t\tfor(int i=1;i<=m;i++) scanf(\"%d%d\",&l,&r),tt[i]=(node){l,r,i};\n\t\tsort(tt+1,tt+1+m,cmp);\n\t\tl=1,r=n;\n\t\twhile(l<=tt[1].l) add(a[l++]);\n\t\twhile(r>=tt[1].r) add(a[r--]);\n\t\tans[tt[1].num]=now;\n\t\tfor(int i=2;i<=m;i++){\n\t\t\twhile(l>tt[i].l+1) del(a[--l]);\n\t\t\twhile(r<tt[i].r-1) del(a[++r]);\n\t\t\twhile(l<=tt[i].l) add(a[l++]);\n\t\t\twhile(r>=tt[i].r) add(a[r--]);\n\t\t\tans[tt[i].num]=now;\n\t\t} \n\t\tfor(int i=1;i<=m;i++) printf(\"%d\\n\",ans[i]);\n\t}\n} \n```\n\n### F \n\n* 大致题意：给出 $a_1…a_n$，$(n \\le 3000)$求：\n  $$\n  \\sum\\limits^{a_1}_{x_1=1}\\sum\\limits^{a_2}_{x_2=1}\\cdots\\sum\\limits^{a_n}_{x_n=1}\\max\\{x_1,x_2,\\cdots,x_n\\}\n  $$\n\n* tag：数学，拉格朗日插值\n\n* 题解：神仙数学题，容易想到求上面这个东西可以转化为求每个数的贡献。若当前最大值为 $i$，则答案为：\n  $$\n  f(i)=i*(\\prod \\min(i,a[j])-\\prod \\min(i-1,a[j]))\n  $$\n  很明显我们要求的就是 $\\sum_{i=1}^{\\max(a_i)} f(i)$，上面这个式子看起来很恶心，考虑转化以下，注意到，当 $k\\in[a_i+1,a_{i+1}]$ 时，公式中的 $\\min$ 可以被去掉，上式转化为：\n  $$\n  f(k)=k*\\prod_{j=1}^ia_j(k^{n-i}-(k-1)^{n-i})\n  $$\n  左边的累乘是个固定值，丢掉，考虑求：\n  $$\n  \\sum_{k=a_i+1}^{a_{i+1}}k*(k^t-(k-1)^t)\n  $$\n  下一步神来之笔出自神仙队友Orz，上式可以转化成：\n  $$\n  \\sum_{k=a_i+1}^{a_{i+1}}(k+1-1)*(k^t-(k-1)^t)\n  $$\n  即：\n  $$\n  \\sum_{k=a_i+1}^{a_{i+1}}(k^{t+1}-(k-1)^{t+1}-(k-1)^t)\n  $$\n  发现左边是典型的裂项相消的形式，所以最后式子就变成了：\n  $$\n  a_{i+1}^{t+1}-a_i^{t+1}-\\sum_{k=a_i+1}^{a_{i+1}}(k-1)^t\n  $$\n  可以 $O(1)$ 求，右边本质上是求 $g(n)=\\sum_{k=1}^n k^t$ ，容易发现 $g_n$ 是一个 $t+1$ 次多项式，可以通过取连续的值来通过拉格朗日插值法 $O(n)$ 求。这样就解决了区间在$k\\in[a_i+1,a_{i+1}]$ 的情况，其余情况分别枚举即可，复杂度 $O(n^2)$ ，需要提前预处理所有阶乘以及阶乘逆元，不然会被卡，别问我为啥555。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  const int mod=1e9+7;\n  const int maxn=2013;\n  int a[maxn];\n  int fac[maxn],y[maxn];\n  int pw[maxn][maxn];\n  int pre[maxn],suf[maxn];\n  int inv[maxn];\n  int fpow(int a,int b){\n  \tint ans=1;\n  \twhile(b){\n  \t\tif(b&1) ans=1ll*ans*a%mod;\n  \t\ta=1ll*a*a%mod;\n  \t\tb>>=1;\n  \t}\n  \treturn ans;\n  } \n  int cal(int x,int n){\n  \tfor(int i=1;i<=n;i++) y[i]=(y[i-1]+pw[i][n-1])%mod;\n  \tpre[0]=x;\n  \tfor(int i=1;i<=n;i++){\n  \t\tpre[i]=1ll*pre[i-1]*(x-i+mod)%mod;\n  \t}\n  \tsuf[n+1]=1;\n  \tfor(int i=n;i>=1;i--){\n  \t\tsuf[i]=1ll*suf[i+1]*(x-i+mod)%mod;\n  \t}\n  \tint ans=0;\n  \tfor(int i=0;i<=n;i++){\n  \t\tint di=1ll*inv[i]*((n-i)&1? (mod-inv[n-i])%mod : inv[n-i])%mod;\n  \t\tans+=1ll*y[i]*(i?pre[i-1]:1)%mod*suf[i+1]%mod*di%mod;\n  \t\tans%=mod;\n  \t}\n  \treturn ans;\n  }\n  int main(){\n  \tint n;\n  \tfor(int i=1;i<=1003;i++){\n  \t\tpw[i][0]=1;\n  \t\tfor(int j=1;j<=1003;j++) pw[i][j]=1ll*pw[i][j-1]*i%mod;\n  \t}\n  \tfac[0]=1;\n  \tfor(int i=1;i<=1003;i++) fac[i]=1ll*fac[i-1]*i%mod;\n  \tinv[1003]=fpow(fac[1003],mod-2);\n  \tfor(int i=1002;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n  \twhile(~scanf(\"%d\",&n)){\n  \tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n  \tsort(a+1,a+1+n);\n  \tint power=n;\n  \tint ans=0;\n  \tint res=1;\n  \tfor(int i=1;i<=n;i++){\n  \t\tint r=a[i],l=(i==1?1:a[i-1]+1); \n  \t\tif(r<l) continue;\n  \t\tint pw1=1,pw2=1;\n  \t\tfor(int i=1;i<=power+1;i++) pw1=1ll*pw1*r%mod,pw2=1ll*pw2*(l-1)%mod;\n  \t\tans+=1ll*res*((pw1-pw2+mod)%mod-(cal(r-1,power+1)-(l-2<0?0:cal(l-2,power+1))+mod)%mod+mod)%mod;\n  \t\tans%=mod;\n  \t\tres=1ll*res*a[i]%mod;\n  \t\tpower--;\n  \t}\t\n  \tprintf(\"%d\\n\",ans);\n  \t}\n  }\n  ```\n\n### E\n\n* 题意：给定序列 $s_n$ ，问任意删除 $m$ 个数后能够得到多少中不同的数列。\n* tag：计数dp\n* 题解：首先不考虑数列是不是一样的，我们令 $dp[i][j]$ 表示到了第 $i$ 个位置，一共删掉了$j$ 个数的答案，很容易写出递推式：$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]$ ，下面考虑把重复的情况删掉，首先，如果删除了第 $i$ 个数，不会重复，现在要考虑的是保留了第 $i$ 个数的情况，如果保留了第 $i$ 个数，可能会出现与之前的重复，若重复，则上一个出现这个字符串的时候，最后一位必然也是 $s[i]$，所以考虑上一个出现 $s_i$ 的位置 $pre_i$ ，如果将$pre_i$ 到 $i-1$ 中的数全部删除，那么现在的情况就和所有 $dp[pre_i-1][j-(i-pre_i)]$ 中的情况重合，所以要把上面的减掉，就能去掉重复的情况，前提：$(i-pre_i)\\le j$ 。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=1e5+13;\nint dp[maxn][13];\nint a[maxn],pre[maxn];\nint main(){\n\tint n,m,k;\n\twhile(~scanf(\"%d%d%d\",&n,&m,&k)){\n\t\tfor(int i=1;i<=k;i++) pre[i]=0;\n\t\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\t\tfor(int i=0;i<=m;i++) dp[i][i]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdp[i][0]=1;\n\t\t\tfor(int j=1;j<=min(m,i-1);j++){\n\t\t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;\n\t\t\t\tif(pre[a[i]]&&i-pre[a[i]]<=j){\n\t\t\t\t\tdp[i][j]=(dp[i][j]-dp[pre[a[i]]-1][j-(i-pre[a[i]])]+mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre[a[i]]=i;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n][m]);\n\t}\n} \n```\n\n### D\n\n* 大致题意：给定图 $G_1$ 和图 $G_2$ ，问 $G_2$ 有多少个生成子图和 $G_1$ 同构，图的点数小于等于 8。\n* 题解：两图同构，即存在一种点的映射使得两图的点集和边集相同。点数只有 $8$ ，所以可以 $8!$ 枚举 $G_2$ 点的所有排列方式，与 $G_1$ 相对应，枚举 $G_1$ 中的每一条边，看 $G_2$ 中是否存在这样的边即可，但是这样可能会产生重复，所以考虑给 $G_2$ 中每一条边定一个编号，由于边数小于等于 $7*8/2=28$ 所以可以状压表示选取边的状态，放入一个 set 中去重即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=13;\nint p2[maxn][maxn];\nvector<pair<int,int>> p1;\nint t[maxn],id[maxn][maxn];\nint main(){\n\tint n,m1,m2;\n\twhile(~scanf(\"%d%d%d\",&n,&m1,&m2)){\n\t\tmemset(p2,0,sizeof(p2));\n\t\tint u,v;\n\t\tp1.clear();\n\t\tfor(int i=1;i<=m1;i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tp1.push_back({u,v});\n\t\t}\n\t\tfor(int i=1;i<=m2;i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tp2[u][v]++;\n\t\t\tp2[v][u]++;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) t[i]=i;\n\t\tint cal=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++) id[j][i]=id[i][j]=cal++;   \n\t\t}\n\t\tset<int> ans;\n\t\tdo{\n\t\t\tint st=0,yes=1;\n\t\t\tfor(int i=0;i<m1;i++){\n\t\t\t\tst|=1<<id[t[p1[i].first]][t[p1[i].second]];\n\t\t\t\tif(!p2[t[p1[i].first]][t[p1[i].second]]){\n\t\t\t\t\tyes=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(yes) ans.insert(st);\t\n\t\t}while(next_permutation(t+1,t+1+n));\n\t\tprintf(\"%d\\n\",(int)ans.size());\n\t}\n}\n```\n\n### I\n\n* 大致题意：定义两个字符串 $u,v$ 同构为两字符串长度相同且存在一个映射 $f$ ,使得对于每一个下标 $i$ 都有 $f(u_i)=v_i$ 。现给定字符集为 $\\{a,b,c\\}$ 长度为 $n$ 字符串，问最多有多少个连续字串满足两两不同构？\n* tag：SAM\n* 题解：考虑字符集为 $\\{a,b,c\\}$ 时的所有可能的映射关系，一共有 6 种，显然任何大于等于2且字符种类数大于1的字符串都可以通过这种映射变成 6 种不同的字符串，我们要求出所有不同构的子串其实就是把同构的字串消掉。所以考虑将当前字符串按照六种映射操作变成新的六种字符串，然后求这六种字符串集合中所有的不同字串。显然原先字符串中相互同构的字串在六种字符串集合中只会产生 6 个不同的字符串，需要特殊考虑所有数字都完全相同的字串，这些字串在六种变换中只会产生 3 个不同的字符串，所以我们需要统计他们的个数并将剩下的 3 倍补上，这样最后的答案除以 6 就是本题的答案。问题是如果求 6 个字符串组成集合的不同字串个数，用 SA 好像是可以做不过很蛮烦，直接用状态机维护每一个字符串即可，跑六遍 SAM，每次都把 $last$ 跟新为1，这样就能同时表示 6 个字符串的状态。 \n\n ```c++\n #include <bits/stdc++.h>\n using namespace std;\n typedef long long ll;\n const int maxn=4e5+13;\n char s[maxn];\n struct SAM{\n \tint len[maxn<<1],fa[maxn<<1];\n \tint ch[maxn<<1][26];\n \tint cnt=1,last=1;\n \tvector<int> p[maxn<<1];\n \t\n \tvoid init(){\n \t\tfor(int i=1;i<=cnt;i++){\n \t\t\tp[i].clear();\n \t\t\tlen[i]=fa[i]=0;\n \t\t\tfor(int j=0;j<26;j++) ch[i][j]=0;\n \t\t}\n \t\tcnt=last=1;\t\n \t}\n \t\n \tvoid insert(int k){\n \tint now=++cnt;\n \tint p=last;\n \tlast=cnt;\n \tlen[now]=len[p]+1;\n \tfor(;p&&!ch[p][k];p=fa[p]) ch[p][k]=now;\n \tif(!p) fa[now]=1;\n \telse\n \t{\n \t\tint q=ch[p][k];\n \t\tif(len[q]==len[p]+1) fa[now]=q;\n \t\telse\n \t\t{\n \t\t\tint add=++cnt;\n \t\t\tfor(int i=0;i<26;i++) ch[add][i]=ch[q][i];\n \t\t\tfa[add]=fa[q];\n \t\t\tlen[add]=len[p]+1;\n \t\t\tfa[q]=fa[now]=add;\n \t\t\tfor(;p&&ch[p][k]==q;p=fa[p]) ch[p][k]=add;\n \t\t}\n \t}\t\t\n \t}\n \tvoid init_tree(){\n \t\tfor(int i=1;i<=cnt;i++){\n \t\t\tp[fa[i]].push_back(i); \n \t\t}\n \t}\n \tll query(int rt){\n \t\tll ans=len[rt]-len[fa[rt]];\n \t\tfor(int i=0;i<p[rt].size();i++){\n \t\t\tans+=query(p[rt][i]);\n \t\t}\n \t\treturn ans;\n \t} \n }sam;\n int p[5];\n int main(){\n \tint n;\n \twhile(~scanf(\"%d\",&n)){\n \t\tscanf(\"%s\",s+1);\n \t\tsam.init();\n \t\tfor(int i=0;i<3;i++) p[i]=i;\n \t\tdo{\n \t\t\tsam.last=1;\n \t\t\tfor(int i=1;i<=n;i++){\n \t\t\t\tsam.insert(p[s[i]-'a']);\n \t\t\t}\n \t\t}while(next_permutation(p,p+3));\n \t\tsam.init_tree();\n \t\tll ans=sam.query(1);\n \t\tint len=1,cnt=1;\n \t\tfor(int i=1;i<=n;i++){\n \t\t\tif(s[i]==s[i-1]) cnt++,len=max(len,cnt);\n \t\t\telse cnt=1;\n \t\t} \n \t\tprintf(\"%lld\\n\",(ans+1ll*len*3)/6);\n \t}\n }\n ```\n\n### H\n\n* 大致题意：给定一颗数，每一条边都有一个权值 $c$，定义从 $u$ 到 $v$ 的路径 $e_1\\to e_2 \\to e_3…\\to e_n$ 的长度为 $\\sum_{i=2}^n (c_{e_i}-c_{e_{i-1}})^2$，对于每一个节点求距离它最近的点\n* tag：树形dp，斜率优化\n\n* 题解：很自然的考虑树形 $dp$，我们固定根为 1 ，对于一个点，距离最小的点无非就只有两种选择，一种是向下走，一种是向上走，向下走的情况，对于向下走的情况，可以通过dfs 来 dp，令 $dw_i$ 为从节点 $i$ 向下走的最优解，为了方便处理向上走的情况，令 $down_i$ 为从 $fa[i]$ 延 $i$ 向下走的最优解，实际上，$dw_i=\\min down_{son_j}$ $son_j$ 即 $i$ 的所有儿子节点。$dw$ 和 $down$ 都可以通过一次 $dfs$ 求出。下面考虑向上走怎么求，从一个点向上走，可以延父节点向上，或者延父节点向下，即达到所有兄弟节点再往下。所以\n  $$\n  up_i=max(up_{fa}+(c_i-c_{fa})^2,max(down_j+(c_i-c_j)^2))\n  $$\n  延父节点向上很好做，直接取一次 $\\max$ 即可，但是到达兄弟节点看形式是一个需要 $O(n^2)$ 的 dp，但是这个形式明显是可以斜率优化的，将所有兄弟节点按照 $c_i$ 排序，之后用单调栈维护 $dp$ 即可，每次栈顶的值都是当前的最优答案。复杂度 $O(n\\log n)$。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+13;\ntypedef long long ll;\nll down[maxn],up[maxn],dw[maxn];\nint c[maxn];\nvector<pair<int,int>> v[maxn];\nstruct node{\n\tll x,y;\n\tint id;\n\tbool friend operator <(node a,node b){\n\t\treturn a.x<b.x;\n\t}\n};\nvoid dfsdown(int rt,int f){\n\tfor(int i=0;i<v[rt].size();i++){\n\t\tint nx=v[rt][i].second,w=v[rt][i].first;\n\t\tif(nx==f) continue;\n\t\tc[nx]=w;\n\t\tdfsdown(nx,rt);\n\t\tdown[rt]=max(down[rt],down[nx]+1ll*(c[rt]-c[nx])*(c[rt]-c[nx]));\n\t\tif(f) dw[f]=max(dw[f],down[rt]);\n\t}\n}\nvector<node> son;\nnode st[maxn];\nbool cmp(node a,node b,node c){\n\treturn 1ll*(b.y-a.y)*(c.x-a.x)<1ll*(c.y-a.y)*(b.x-a.x);\n}\nbool judge(node a,node b,int id){\n\treturn b.y-a.y<=1ll*(b.x-a.x)*2*c[id];\n}\nvoid dfsup(int rt,int f){\n\tson.clear();\n\tfor(int i=0;i<v[rt].size();i++){\n\t\tint nx=v[rt][i].second,w=v[rt][i].first;\n\t\tif(nx==f) continue;\n\t\tif(f) up[nx]=max(up[nx],up[rt]+1ll*(c[rt]-c[nx])*(c[rt]-c[nx]));\n\t\tson.push_back({c[nx],down[nx]+1ll*c[nx]*c[nx],nx});\n\t}\n\tint sz=son.size();\n\tsort(son.begin(),son.end());\n\tint top=0;\n\tfor(int i=0;i<sz;i++){\n\t\tint id=son[i].id;\n\t\twhile(top>1&&judge(st[top-1],st[top],id)) top--;\n\t\tif(top) up[id]=max(up[id],down[st[top].id]+1ll*(c[id]-c[st[top].id])*(c[id]-c[st[top].id]));\n\t\twhile(top>1&&cmp(st[top-1],st[top],son[i])) top--;\n\t\tst[++top]=son[i];\n\t}\n\ttop=0;\n\tfor(int i=sz-1;i>=0;i--){\n\t\tint id=son[i].id;\n\t\twhile(top>1&&judge(st[top-1],st[top],id)) top--;\n\t\tif(top) up[id]=max(up[id],down[st[top].id]+1ll*(c[id]-c[st[top].id])*(c[id]-c[st[top].id]));\n\t\twhile(top>1&&!cmp(st[top-1],st[top],son[i])) top--;\n\t\tst[++top]=son[i];\n\t}\n\tfor(int i=0;i<v[rt].size();i++){\n\t\tif(v[rt][i].second==f) continue;\n\t\tdfsup(v[rt][i].second,rt);\n\t}\n}\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\tfor(int i=1;i<=n;i++) v[i].clear(),up[i]=down[i]=dw[i]=0;\n\tfor(int i=1;i<=n-1;i++){\n\t\tint u,vv,w;\n\t\tscanf(\"%d%d%d\",&u,&vv,&w);\n\t\tv[u].push_back({w,vv});\n\t\tv[vv].push_back({w,u});\n\t}\n\tdfsdown(1,0);\n\tdfsup(1,0);\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%lld\\n\",max(up[i],dw[i]));\n\t}\n\t}\n}\n```\n\n","tags":["2021summertraining"],"categories":["算法","刷题"]},{"title":"Educational Codeforces Round 105 (div2)","url":"/2021/04/28/Educational-Codeforces-Round-105-div2/","content":"\n### Educational Codeforces Round 105 (Rated for Div. 2)\n\n<!--more-->\n\n#### A\n\n* 大致题意：给定由 $A,B,C$ 组成的字符串，将 $A,B,C$ 分别替换成 '(' 或者 ')' ，并且要求同一个字母只能替换成同一种括号类型，要求括号能够相互匹配，问是否能够实现？\n* 题解：暴力枚举每一种替换情况然后作判断即可，复杂度 $O(8n)$\n\n#### B\n\n* 大致题意：给定一个方格正方形，现在要寻找一种给所有靠近边的方格涂色的方式，需要保证涂色结束后，上下左右四条边分别满足有 $U,D,L,R$ 个格子被涂色。问是否存在这样的方式。\n* 题解：~~一看就是专门毒我的题~~，实际上很简单，考虑只有边上有 $n-1$ 或者 $n$ 个格子被涂色，才会有可能对其他边有影响，所以可以分别考上下两个格子和左右两个格子，如果一条边要涂 $n$ 个格子，需要给与它靠近的两条边的格子数减一，如果一条边要涂 $n-1$ 个格子，需要给两边中格子数量最多的边得格子数量减一，每处理完相对的两条边后，判断临近两条边是否小于 0，若小于 0，则不成立，否则一定是成立的。\n\n#### C\n\n* 大致题意：给定 $n$ 个箱子，$m$ 个目标位置，这些箱子和目标位置都位于坐标轴上的某一个位置，一个人从坐标原点出发，向左或者向右走，如果人在移动过程中碰到了一个箱子堵住路，会把箱子往子集移动的方向以东，同理一个箱子也可以移动另一个箱子。问人怎样移动才能让更多的箱子在目标位置上。\n* 这题思路很简单，但是十分考验马力，~~每次这种时候我都死了~~，做法自然是枚举，但是怎么枚举是个问题。考虑到有两个方向，不难发现两个方向等价，只需要考虑一个方向，另一个方向很容易类比得到。考虑正方向，注意到一开始就可能有处于目标位置的箱子，需要预处理，用map记录 a 数组（箱子位置），然后枚举b数组（目标位置）即可。之后考虑到 a,b 数组中的数的数据范围都很大，不可能一个单位一个单位的枚举，所以考虑每次枚举一段，注意到对于每一种覆盖情况，我们都可以通过适当的移动来使得其中一块靠近一个目标位置边界，而不改变答案值，所以考虑枚举最右边的箱子正好在一个目标位置的情况，之后用二分可以算出此时的答案，对于所有情况取个最大值即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+13;\nvector<int> a,b,c,d;\nmap<int,int> mp;\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\ta.clear(),b.clear(),c.clear(),d.clear();\n\tmp.clear();\n\tint n,m,x;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tif(x<0) c.push_back(-x);\n\t\telse a.push_back(x); \n\t} \n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&x);\n\t\tif(x<0) d.push_back(-x);\n\t\telse b.push_back(x);\n\t}\n\tsort(c.begin(),c.end());\n\tsort(d.begin(),d.end());\n\tint r=0;\n\tfor(int i=0;i<a.size();i++){\n\t\tmp[a[i]]=1;\n\t}\n\tfor(int i=0;i<b.size();i++){\n\t\tif(mp[b[i]]) r++;\n\t}\n\tint ansl=r;\n\tfor(int i=0;i<b.size();i++){\n\t\tif(mp[b[i]]){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t    else{\n\t    \tint rk1=upper_bound(a.begin(),a.end(),b[i])-a.begin();\n\t    \tint rk2=lower_bound(b.begin(),b.end(),b[i]-rk1+1)-b.begin()+1;\n\t    \tansl=max(ansl,r+i+1-rk2+1);\n\t\t}\n\t}\n\tmp.clear();\n\tr=0;\n\tfor(int i=0;i<c.size();i++){\n\t\tmp[c[i]]=1;\n\t}\n\tfor(int i=0;i<d.size();i++){\n\t\tif(mp[d[i]]) r++;\n\t}\n\tint ansr=r;\n\tfor(int i=0;i<d.size();i++){\n\t\tif(mp[d[i]]){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t    else{\n\t    \tint rk1=upper_bound(c.begin(),c.end(),d[i])-c.begin();\n\t    \tint rk2=lower_bound(d.begin(),d.end(),d[i]-rk1+1)-d.begin()+1;\n\t    \tansr=max(ansr,r+i+1-rk2+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ansl+ansr);\n   }\n} \n```\n\n#### D\n\n* 大致题意：规定一颗有权树上父节点的权值一定会大于子节点，现在给定叶节点的个数和叶节点两两之间的$lca$ 的权值，二且每个非叶子节点都至少有两个子节点，要求还原这颗树（包括每个点的权值）。\n* 题解：初始我们有的是两两节点之间一共 $n^2$ 个节点，首先，每个叶节点和自身的 $lca$ 一定是自己，所以我们首先能够得到每个叶节点的权值。因为父节点权值始终大于子节点，所以可以考虑给节点对按照权值排序，显然排名越靠前的节点在树上的位置越低，所以考虑使用并查集从下往上合并，每次从左往右枚举节点对，如果两个节点已经在一个并查集中说明已经被合并过了，跳过，如果不是，如果这两个节点所在并查集的父节点权值最大值与对点对权值相同，说明一个是另一个的父节点。否则说明出现了新的祖先节点，定义一个新节点即可。因为是按顺序枚举的而且每个非叶子节点都至少有两个子节点，所以并不存在新增节点和当前两个节点直接还夹有未被枚举的节点的情况。另：排序以权值为第一关键词，还要以两个节点为第三第四关键词，否则会出现，1234 都是 5 的子节点，但是先合并 12 后合并 34，导致多出一个节点。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+13;\nstruct node{\n\tint val,i,j;\n}tt[maxn];\nint fa[maxn],ans[maxn],f[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nbool cmp(node a,node b){\n    if(a.val==b.val){\n    \treturn a.i==b.i?a.j<b.j:a.i<b.i;\n\t}\n\telse return a.val<b.val;\n}\nint main(){\n\tint n,x;\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(i==j) ans[i]=x,fa[i]=i;\n\t\t\telse{\n\t\t\t    tt[++cnt]=(node){x,i,j};\t\n\t\t\t}\n\t\t}\n\t}\n\tsort(tt+1,tt+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++){\n\t\tint f1=find(tt[i].i),f2=find(tt[i].j),now=tt[i].val;\n\t\tif(f1==f2) continue;\n\t\tif(max(ans[f1],ans[f2])==now){\n\t\t\tif(ans[f1]>ans[f2]){\n\t\t\t\tfa[f2]=f1;\n\t\t\t\tf[f2]=f1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfa[f1]=f2;\n\t\t\t\tf[f1]=f2;\n\t\t\t}\n\t\t}\n\t\telse if(max(ans[f1],ans[f2])<now){\n\t\t\tn++;\n\t\t\tfa[n]=n;\n\t\t\tf[f1]=f[f2]=n;\n\t\t\tfa[f1]=fa[f2]=n;\n\t\t\tans[n]=now;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\tint rt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(find(i)==i){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",rt);\n\tfor(int i=1;i<=n;i++){\n\t\tif(i!=rt){\n\t\t\tprintf(\"%d %d\\n\",i,f[i]);\n\t\t}\n\t}\n}\n```\n\n\n\n#### E\n\n* 大致题意：动态操作一张图，图上每一条边都有一个字母，每次可以选择在图上加边或者在图上减边，查询操作为，给定数字 $k$ ，问图上是否存在一个有 $k$ 个点的路径，使得正着走和反着走得到的字母序列完全相同？\n* 题解：假题，对于每个查询，如果 $k$ 是奇数，只要判断图上是否存在连接两个点的两条反向边即可，可以证明这是上述条件的充要条件。比较显然，如果k是偶数，只要判断图上是否存在连接两个点的两条同权值的反向边，同理，这也是条件成立的充要条件，简证：如果图上现在存在连接两个点的两条同权值的反向边，假设为$u,v$，则路径 $u\\to v \\to u \\to v$ 即满足条件。如果图上存在题目所说的路径，$v_1 \\to v_2 \\to v_3……\\to v_{2n}$ 由条件知道，它与 $v_{2n} \\to v_{2n-1} \\to v_{2n-2}……\\to v_{1}$ 产生相同的字母序列，则必有  $v_{n+1}$ 与 $v_n$ 之间存在两条同权值的反向边，得证。具体操作开一个 map 维护加边和删边即可。\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"coderforces round 706(div2)","url":"/2021/04/28/coderforces-round-706-div2/","content":"\n### codeforces round 706（div2）\n\n<!--more-->\n\n#### A\n\n* 大致题意：给定一个字符串 $s$，和一个整数 $k$ ，问是否存在 $k+1$ 个字符串满足：\n  $$\n  s=a_1+a_2+\\ldots +a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\\ldots+R(a_{1})\n  $$\n  其中 $k$ 满足 $k\\le \\lfloor{\\frac{n}{2}}\\rfloor$ ，$R(x)$ 表示将 $x$ 反转后得到的字符串。\n\n* 题解：签到，~~签了一个寂寞~~ ，不难发现，上面的构造字符串的形式，除中间的 $a_{k+1}$ 以外，其它的组成都是回文串的形式，所以贪心的想，求出前后缀满足回文串特性的最长形式，之后判断剩下不回文的片段是否大于$0$ 即可，ps：注意对于偶数的情况需要特判，即使整个串都是回文的也要为 $a_{k+1}$ 预留一个位置。\n\n#### B\n\n* 大致题意：给定一个可重集合 $S$，每次进行一次如下操作：\n\n  * 将 $\\lceil\\frac{\\text{mex}(S)+\\max(S)}{2}\\rceil$ 放入集合 $S$ 中。\n\n  问进行 $k$ 次操作后会剩下多少个元素。\n\n* 题解：思维题，可以分两种情况来考虑，先考虑一个普遍的情况，如果 $\\text{mex}(S)\\le\\max(S)$ ，则，易知每次进行如上操作不会改变 $\\max(S)$ 和 $\\text{mex}(S)$ ，所以无论多少次操作都至多新增一个数。一种特殊情况，$\\text{mex}(S)>\\max(S)$ ，即集合中的数是 $0,1,2,……，n$ 这样的形式，上述操作每次会新增一个最大值，且将最大值加一，所以答案就是集合数量加上 $k$ 。\n\n#### C\n\n* 大致题意：给定一个二维坐标系，规定 $n$ 个黄金矿工都在 $y$ 轴上，$n$ 个金矿都在 $x$ 轴上，每个矿工都只能挖一个金矿，需要花费 $dis(x,y)$ 的代价，问怎么安排才能使得挖完所有金矿的总代价最低？\n* 题解：几何题，将 $x，y$ 轴上的所有点按绝对值分别排序，一一对应求距离相加即可。为啥这样最优呢，其实基于一个初中就证明过的平面几何性质：梯形对角线之和大于上下两条底边之和。所以每次取相对平行的边一定是最优的。\n\n#### D\n\n* 大致题意：给定一个排列 $p$ ，两人做博弈，一开始两个人选择 $p$ 中的一个位置，A 先选，B 后选，选择完成后，A 可以向左边或者右边移动一格，规定移动到的位置 $x$ 相对与原来的位置 $x_0$ 必须满足 $p_{x_0}<p_x$ ，对于B来说，每次移动的位置 $y$ 相对原来的位置 $y_0$ 必须满足 $p_{y_0}>p_y$ ，两人不能位于同一点，最先不能走的人失败。问有多少个点是必胜点。\n* 题解： 博弈论思维题，首先显然任何排列都可以写成许多波峰的拼接，A 每次会向下走，B 每次会向上走。首先，对于先手来说一定要选择在最高的一个峰顶，否则，后手可以选择从最高峰的最底段开始往上走，这样一定会比先手走的步数多。\n  * 情况1：最高峰高度为奇数，则后手可以赌先手，先手必输\n  * 情况2：最高峰高度为偶数，而且对于最高的峰顶，如果最高的峰顶有两个以上，那么先手还是必输，因为先手和后手都会选择一个最高的峰，但是因为先手先走，所以先手会先走不了（这时后手还剩下一步可以走）\n  * 情况3：现在假设只有一个最高峰，先手还是不一定赢~~太惨了~~，因为后手可以选择从最高峰的底端上一个位置出发，这样还是可以堵住先手，而且先手走另一个方向，先手可走的距离小于后手，先手必输。\n  * 情况4：最高峰出发，向左向右高度都一样，这样先手必赢，因为此时若后者采取情况3的策略，则先手走另一个方向，正好可以比后手多走一个回合，先手必赢。\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"BUAAOO Unit1总结博客","url":"/2021/04/09/BUAAOO-Unit1总结博客/","content":"\n### 面向对象第一单元总结博客\n\n经历过三周的OO学习经历，下面我想分享一下我关于第一单元作业的设计架构和心得体会。\n\n<!--more-->\n\n#### PART ONE 架构相关（UML类图与耦合度分析）\n\n> **第一次作业**\n\n**UML类图**\n\n![](/images/hw1photo.jpg)\n\n以上使用IDEA自带的工具画出的 UML 类图，可以直观地看到第一次作业我大概开了三个类分成了，主类，处理字符串的类和主类，注意到我并没有开一个表达式类来存放表达式，而是直接在主类中开了一个 Term 的 Arraylist 来表示表达式。可以说，整个过程是十分面向过程的……但是由于题目比较简单，所以影响不是很大。\n\n**Method metrics**\n\n![](/images/hw1methodmetrcs.png)\n\n****\n\n**Class metrics**\n\n![](/images/hw1classmetrics.png)\n\n可以发现大致复杂度全出在 Member（项）方法的求导函数和主函数中。实际上，这两个地方由于也第一次写OO意识不够，很多地方就直接用一种面向过程的方法是实现了，将方法当函数用，导致部分复杂度过高。\n\n> **第二次作业**\n\n**UML类图**\n\n![](/images/Term.jpg)\n\n这个图相比于第一次几乎是膨胀了2倍，为什么呢，这就不得不谈到我本次十分鲁莽的架构了。第二次作业为表达式的形式添加了括号。为了解决这个问题，我采用了一个循环嵌套式的架构。我先设计了所有的因子类—— cos 类，sin类，幂函数类，之后设计了项类，根据定义，项由许多 cos 项和 sin 项，幂函数项以及系数组成，所以我利用不同的 Arraylist 表示这些因子，这也是我觉得这个设计最失败的地方，后面说遗憾的时候还会说。\n\n除此之外，为了尽量降低第三次作业的工作量，我在这次作业中也实现了嵌套函数的求导方法，因为我觉得，括号嵌套的模式和函数嵌套的模式实现起来其实把并没有太大的区别。我做的主要的设计是在 sin 和 cos 类中添加一个表达式类型的元素，求导时再次调用表达式求导的方法，由于最后表达式一定会递归到幂函数或者常数，所以递归不会出现找不到终点而爆栈。\n\n**Class Metrics**\n\n ![](/images/hw2metrics.png)\n\n可以发现许多地方耦合度是相当高的，主要问题还是出在一些特殊处理比较多的地方，比如 toString()，equals()。这些函数中我为了尽量降低字符串的长度加了大量特判。\n\n> **第三次作业**\n\n**UML类图**\n\n![](/images/hw2photo.jpg)\n\n是不是更加可怕了（x），鉴于第二次作业没有出bug，所以尽管有简化代码的想法但最后还是没有去实践，只是在原先的基础上另开了一个类用于检查格式是否正确，还有开了一个异常处理类用于抛出异常。\n\n整体上还是采用了两种架构跑之后比输出长度的思路，因为第三次加的功能第二次的架构完全能够支持，所以我并没有改动了太多，但是为了符合定义的情况下，获得较好的性能分做了很多的输出优化，改动了大部分类的 toString() 方法。\n\n**Class Metrics**\n\n![](/images/hw3metrics.png)\n\nemmm……，真惨（，循环复杂度高，大概是因为我用的所有的容器都是 Arraylist 吧，基本所有操作都是循环完成的，复杂度轻轻松松冲上 $O(n^2)$ ，此外由于并没有用层次结构，存在一些暴力枚举和暴力判断。其实本来还觉得自己写的不错，但是看了这个分析，我发现我写的万一原来是~~垃圾~~，希望以后的作业中能尽量写出一些漂亮的架构。\n\n#### PART TWO 设计与算法相关\n\n> **第一次作业**\n\n第一次作业的总体需要达到的目标是实现简单只含有幂函数的表达式的求导，乍一看这应该是一个很简单的事情，在学习程序设计和数据结构的时候就写过类似的程序。但是题目给出的是一个经过**重定义**的表达式模型，这就对我们需求分析的能力提出了挑战。经过一段时间的分析后，我大概将本次实现本次作业的流程分为三个部分，解析字符串，对表达式求导和输出表达式，在第一单元的以后几次作业中我一直沿用这样的实现流程，由于要求比较直接，所以也不需要太复杂的流程。\n\n对于第一个流程解析字符串，对于本次作业来说难度主要是构造出正则表达式，并将信息提取。一开始由于对于正则表达式不够熟悉，所以和室友讨论了很久才设计成功，最终得到了一个十分冗长的表达式\n\n```java\n(?<member>[+-]?([+-]?([+-]?((\\\\d+)|(x(\\\\*\\\\*[+-]?\\\\d+)?))\\\\*)*[+-]?((\\\\d+)|(x(\\\\*\\\\*[+-]?\\\\d+)?))))\n```\n\n上述表达式是不包括空格的，目标是捕获出所有的“项”，所以我在进行匹配之前先去除了所有的空格。之后又        通过$\\text{java matcher}$ 类中的 $\\text {group}$ 方法捕获每个项对应参数，并对乘积形式的项进行合并指数。\n\n对于第二个流程，这里就需要谈谈我的类的设计架构，说实话，由于做第一次作业时候对于面向对象的思想了解不够，对整体架构的设计不是很明智，基本上只是分成了三个类，主类，项类和处理字符串类。项类（Member）支持查询指数和系数，以及输出求导之后的字符串，然后我直接在主类中用一个 $\\text {ArrayList<Member>}$ 来表示一个表达式，实现求导。\n\n对于第三个流程，在我目前的架构下，其实就是对容器中的项分别求导然后进行拼接问题。\n\n**关于优化**\n\n第一次的输出优化是可以达到极致的，我注意到了许多可以优化的地方，包括合并同类项，将 $x**2$ 转化为 $x*x$ ，以及将正系数的项放在第一个，这样可以少输出一个符号等，我也确实都做了。这些也基本是一些简单的模拟，非常好实现。\n\n**关于自己的bug**\n\n这次出了两个bug，一个是书写 toString 函数时出现了笔误，将指数写成系数，不过由于是在一个特判中的错误，被测出来的可能很小，所以真的很佩服 hack 掉我的同学……\n\n另一个直接导致我强侧一个点挂掉了……在输出优化时未考虑到项出现多个零的情况，导致有时候会不输出 0。\n\n这两个都是很细节的 bug 所以改完前后代码行和圈复杂度几乎没有变化。\n\n**关于他人的bug**\n\n这次我找到了别人的一个 bug。由于最开始阅读代码时并没有看出 bug，所以之后我直接使用 python 评测机来自动生成数据来测试，最后发现了一位同学在一种情况下对于 x 的求导还是 x，于是我就把他 hack 掉了。\n\n> **第二次作业**\n\n这次作业应该是三次作业中最完美的一次了，但是也经历了漫长的思考，设计，码代码和测试并优化的过程。\n\n第二次作业的要求中在原先的幂函数求导的要求上另加了对三角函数的求导过程，并附加了括号的嵌套，这就给整个表达式的呈现方式提供了很大的灵活性。好在指导书上给出了目标表达式的形式化表述，从逻辑上固定了表达式的形式，而且不存在不合法的表达式，也就是说一定可以使用正则表达式将式子表示出来，这样一定程度上降低了解析表达式的难度。\n\n对于解析表达式，根据上述的分析。由于表达式形式被严格定义完成，所以可以沿用上述的方式用正则表达式去严格解析，但是，括号的出现给解析带来了很大的难度，因为表达式和项都是递归定义的！经过与室友的一番讨论，我最终确定了如下的解析算法。注意到，任意表达式都能写成：\n$$\n\\sum kx^p*f_1(x)*f_2(x)*f_3(x)…*f_m(x)*(…)_1*(…)_2…(…)_n \\\\\n k,p,m,n \\in N\n$$\n如果我们将所有括号中的表达式都去掉，就会得到如下的结果：\n$$\n\\sum kx^p*f_1()*f_2()*f_3()…*f_m()*()_1*()_2…()_n \\\\\n k,p,m,n \\in N\n$$\n而这样的形式，就能设计合适的正则表达式去描述，这里我不再展示我当初写出来的正则表达式（~~因为又臭又长~~），在第三次作业我再重点说一种合适的构造正则表达式的方式。按照第一部分所设计出的架构，可以将上述连续乘积形式的每一部分对应到一个固定的因子类，分别进行处理，然后整体得到一个项类，最后将项类组成一个表达式类。这样这样一个表达式就处理成我们想要的样子了。\n\n但是括号里的东西就不要了嘛？当然不是，可以发现，括号里的东西也是一个表达式啊，所以可以重复上述操作就好了啊，编程中什么样的结构形式支持这种反复调用自己的需求呢，当然是递归，怎么递归？对表达式预处理啊，每次都将第一层括号拆开，将括号中的表达式都存在一个数组中，同时删去这一部分。上述过程不就是我们非常熟悉的括号匹配问题嘛？实现它的方法在数据结构课程中就已经教授了，这里不再赘述。每次先递归处理括号内的表达式再处理当前表达式，这就是一个递归的过程。那么递归的终点是什么？就像前面介绍架构说的，循环嵌套的模式，不会达不到重点，在本次作业的终点就是表达式 $x$ ，且如果实现形式没有问题，是一定可以达到这个终点的。\n\n到此为止，我们基本就可以将表达式从字符串形式转化成我们想要的形式了。之后再调用表达式类的求导的方法便可以得到答案了。\n\n再谈谈求导的实现思路，首先有这样的一个公式\n$$\n(\\prod f_1(x)*f_2(x)…f_n(x))^{'} =(f_1(x))^{'}*f_2(x)…f_n(x)+(f_2(x))^{'}*f_1(x)…f_n(x)+(f_n(x))^{'}*f_1(x)…f_{n-1}(x)\n$$\n也就是说对于乘积的导函数，可以分别对每一项求导，其它不变。对于表达式求导，可以分别求导然后将结果加起来。\n\n既然都设计了这样的循环嵌套的结构，~~不如把第三次的一部分也写了~~，抱着这样的想法，我也实现了嵌套函数的求导，其实也就是 $sin(f(x))$ 和 $cos(f(x))$ 的求导，其实实现起来很简单，因为\n$$\nsin(f(x))^{'} = cos(f(x))*f(x)^{'} \\\\\ncos(f(x))^{'} = -sin(f(x))*f(x)^{'}\n$$\n其实调用一下表示求导，以及将 $sin$ 类换成 $cos$ 类，或者相反就行了……，对于不拆括号的版本和拆括号的版本都很好实现。\n\n**关于优化**\n\n输出优化，合并同类项等，思维难度和实现难度都不大，不多赘述。\n\n前面说过，为了使结果尽可能的短，我实际上实现了两种求导的方式。最初我的想法是，在预处理字符串时候将符号全部拆开来，并合并同类项，最终得到的表达式就不包含任何括号，然后直接进行求导，这种方法得到的结果，由于没有括号的嵌套，有时候会十分的长，而想要进一步优化，只能写合并同类项的方法，实现困难且容易出错。那么怎么做到尽量合并同类项呢，注意到表达式中就存在括号相乘，我为什么一定要拆开呢？于是这就产生了我的第二个架构，不拆括号版本。具体架构上面已经说过，细节实现上与拆括号版本没有太多的区别，只是不再增加表达式相乘的模块，将括号表达式看作一个因子放入项类中。解析表达式和求导方式类似，只是不赘述。\n\n最终我将两个求导方式放入两个包中，取最优结果输出。\n\n**关于DEBUG**\n\n对于第二次作业，在测试过程中，出了一个令我 de 了很时间的 bug ，就是对于不拆括号的版本中，由于我为了使得结果尽可能的精简，做了很多的特判，导致由于反复调用$toString()$ 方法，导致递归层数指数式增涨，最终导致对于某些样例复杂度过高而运行超时。对于同一个情况下只需要记忆化递归后的结果然后做出判断即可，不需要反复递归。 \n\n这次debug的经历也提醒我了，记忆化对搜索这样很容易就复杂度爆炸的算法能起到很大很大的简化，当然类似的算法还有剪枝等，只不过这里并用不着。\n\n**自己的bug**\n\n本次作业并没有出 bug ~\n\n**他人的bug**\n\n本次互测中，在阅读了一位同学的代码后，发现它无法处理常熟求导（这不是样例嘛喂(#`O′)），然后就构造了样例把他 hack 掉了，其他几位同学看代码并没有看出明显的 bug，于是还是用评测机跑，最终又hack掉了一位同学，分析它的代码后，发现他（她）的代码无法处理三个符号的情况，于是我又干掉了这位同学。\n\n\n\n> **第三次作业**\n\n本单元最后一次作业，相较于第二次多了一个三角函数中允许嵌套表达式的模式，以及一个检查格式是否正确的功能。\n\n对于第一个功能，其实上次我已经实现了，所以这次作业压力很小，相当于只要按照要求调格式和实现检查格式功能即可。实际上，这次作业写码部分并没有花我很多时间，反倒是因为一些新加的细节 $\\text {de}$ 了很多 $\\text{bug}$…… ，嵌套的实现前面已说过，不再赘述，这次作业最大的两个问题是格式判断和输出优化。\n\n**关于格式判断**\n\n如何指明错误的表达式？有个很朴素的想法，用正确的正则表达式来捕获它，如果得到的表达式是和原表达式没有差别的，那么就是正确的表达式，否则就是错误的表达式。\n\n所以设计好一个正则表达式很重要。然而第三次作业的表达式形式相当的复杂，不是很容易就能表示出来的形式，那怎么办？注意到，我们有形式化定义！形式化定义其实就是正则表达式！所以按照形式化定义的写法一步步递进即可。\n\n![](/images/tu.jpg)\n\n所以课程组给我们的指导书还是很良心的……\n\n判断格式的流程如下：\n\n* 先对所有括号进行匹配，如果括号无法匹配，直接抛出异常\n* 去除表达式前后的空格，之后判断表达式是否为空，如果为空，直接抛出异常。\n* 做括号匹配，同之前的一样，提取括号中的表达式，之后对处理后的串做匹配。这里需要注意一下，这里表达式需要分为三角函数中的表达式和不同的表达式，可以用一个参数 id 来表示，如果是三角函数中的表达式，需要特殊判断它是否是一个因子。\n* 如果表达式合法，解析表达式，判断当前表达式中每一对括号的归属，也就是计算 id，然后对从括号中提取的表达式进行递归判断。\n\n中间其实涉及到了很多细节，我就因为一个细节没有注意到（对空串的判断），导致最终错了一个测试点……\n\n**关于优化**\n\n首先是输出优化，题目中规定了，三角函数中只能嵌套因子，因此，在很多地方需要补充添加一些括号。但是为了尽量缩短结果，我选则加了一个方法判断当前 项/表达式是否是一个因子，这样可以少加一个 $()$。\n\n其次是方法优化，其实我沿用了之前的架构，从不拆括号和拆括号的两种情况中选择一个最短情况输出。\n\n**关于自己的bug**\n\n这次其实也存在有两个bug，一个被测出来了，一个到最后也没有被发现。\n\n第一个 bug 是被发现了，强测也为此付出了代价。我在去除空格的那里，在while循环语句中，将边界判断放在了对值的判断之后，导致执行判断语句时先执行前面的语句就会导致数组访问越界，该换一下判断顺序就行了。这样一个比较基本的bug，甚至在写c语言是就很容易犯的bug，都没有测出来实在是我的失误。\n\n第二个 bug 是审题失误，没有看到 $0^0 = 1$，但是最后课程组并没有测试这个点，强测这个点也被ban掉了，所以逃过一劫……\n\n**关于他人的bug**\n\n这次由于互测限制实在是太多导致到最后都没有谁 hack 谁成功了…… 但是我找出很多同学的对于 WF 的判断有很大的问题。比如一位同学对于诸如 $sin(+x)$ 这样的样例都没有判成 WF ，但是我始终无法进行hack，这我认为是十分遗憾的，这次我依旧使用python的自动评测机来对它们的代码进行测试。\n\n####  PART THREE 心得和体会\n\n**一些收获**\n\n在做这次作业之前，我也写了 pre 的作业，在写 pre 之前，我对面向对象的设计方法完全不了解，甚至在写完pre时，我脑中对于面向对象的方法也十分模糊。可能是因为之前我并没有写过 java 语言的程序，在 pre 中熟悉 java的语法就耗尽了我的全部精力吧……\n\n在第一次作业中，尽管想尝试这用一些面向对象的方法，但最后写着写着又不自觉地用一种 “四不像”的方法实现了。但是通过设计和使用 “项“ 类，我还是对”对象“这样一个存在获得了更深的理解。\n\n第二三次作业由于复杂度的飙升，面向对象的方法相较于面向过程的优势被凸显出来，通过构造出因子类，项类，表达式类，分别实现他们的 clone()，toString()，derivative() 方法，整个复杂的问题就被分解为每个对象负责的一个又一个小问题，最终只需要调用表达式类一个简单的方法就可以将问题成功解决。将问题分解为每个对象起的作用，而不是每一步要干些什么，这样一种设计方式极大的简化了求导的过程和写代码的难度。除此之外，面向对象方法给代码提供了很强的可维护性，我在写完第一个拆括号的方法后，没花多长时间就将不拆括号的版写出来了，因为很多类起到的作用是相差无几的。总之，通过这两次作业我切实体会到了面向对象的魅力。\n\n**一些遗憾**\n\n三次作业只有一次获得了满分，虽然几乎每次作业在性能分上几乎都拿满了，但除了第二次其他两次都不同程度上出了一些细节上的 bug，一方面说明了我在写代码时不够专心，同时也反应了很多时候我没有考虑足够全面就开始了码代码，导致很多时候就注意不到一些足以致命的细节，也许这就是程序猿之痛吧。回过头来看，其实性能分确实不占多少分（因为每次都发现性能分几乎都是99.99……这样的数字），反倒出现错误损失更大，所以这几次真是捡了芝麻丢了西瓜。\n\n虽说三次作业都没有出现毁灭性的架构问题，但这不代表我在这三次的作业的架构没有任何问题。对于第一次作业来说，我之前也说过，写了一个四不像的架构，几乎是面向过程完成的，就不说了。对于后面两次作业，我写了两个版本，其中其实很多都是复制粘贴的，这样的设计虽然第二第三次作业中没有在这里出现问题，但是事后想想，我觉得这样还是十分危险的，每次出现问题都需要维护两个版本，很容易出错。下面列出了我思考的几个可以改善的方向。\n\n* 取消愚蠢的 “双版本” 模式，将两种版本融合，实际上，可以直接在 “项” 类和 \"表达式\" 类中开一种方法表示拆括号的情况，解析表达式，求导等步骤之前都采用不拆括号的模式处理，之后再判断得到的结果查括号更短还是不拆括号更短。\n* 开一个抽象类表示因子维护，指数 ，获取指数，展示指数，clone，toString ，derivative 等方法，其它四类因子继承这个抽象类，这样就方便 ”项“ 类统一管理，相较于我现在的版本可以减少很多码量。\n\nOO第一次作业结束了，~~太tm过瘾了~~，期待可以在以后的OO学习中加深对面向对象方法的理解，提升我的写代码能力，成为一个更加成熟的程序猿。","tags":["BUAAOO"],"categories":["OO","Unit1"]},{"title":"2021寒假训练8","url":"/2021/03/17/2021寒假训练8/","content":"\n### 寒假训练8\n\n> 这场感觉考了很多我很久没有接触过的算法，结果我就gg了，但是这也正好能帮我复习一下这些算法，我感觉挺不错的。\n\n<!--more-->\n\n#### A\n\n* 大致题意：一开始数列 $a$ 中的数全是 $0$ ，还有一个数列 $b$ ，每次可以进行一次如下操作：\n\n  > 将 $a_i+1$ 赋值给 $a_{i+1}$\n\n​       问最少需要多少次操作可以使得 $a$ 变为 $b$ \n\n* 大致题解：首先判断不成立的情况，按照操作规则，易知第一项一定是 $0$ ，对于两个相邻的数，如果 $a_{i+1}>a_i$ ，那么一定有 $a_{i+1}-a_i=1$ ，其余情况一定都可以通过上述操作得到。下面考虑最少操作，对于数值连续的子段，比如，$1,2,3$ ，可以发现，最少可以通过 $3$ 次来得到，因为可以连锁操作，否则，需要等于其数值的操作数来得到，正确性比较显然（猜就完了），$O(n)$ 即可处理。\n\n#### B\n\n* 大致题意：给一串字符表示的数字，规定了数字的长度，和数字应该被删去的字符个数，规定合法数字不能出现前导零，问如何删字符串才能使字符串最终形成一个合法数字，而且该数字可以被 $3$ 整除。\n* 题解：数字能被 $3$ 整除，也就是数字和能被 $3$ 整除，然后不能出现前导零，而且需要删去正好 $k$ 个数被删去，基本上看到这就能进本断定这大概是个~~垃圾题~~，按照官方题解的做法是，先计算所有数的和，​然后​如果​当前​数字和模 $3$ 余 $0$，那么贪心的从前往后删，如果当前的数字模 $3$ 大于 $0$，就从后往前删，这明显是符合贪心的规律的，但是这代码我这个菜:chicken: 真写不出来，后来​张 :older_man: :older_man:说了一个巨强的做法，就是直接枚举第一个选到的数字，假设在这之前的数字全被删去，这是可以统计还剩下多少数，问题转化为从一些数中选一些数使他们的和被 $3$ 整除，不用考虑前导零的问题，对于这个问题，可以再次简化。\n  * 如果当前只剩下 $0,1,2$ 那么可以直接判断当前是否成立\n  * 如果当前剩下 $0,2$ ，可以发现这些数的选取两两都相差 $2$ ，在区间 [先选 $0$ 再选 $2$，先选 $2$ 再选 $0$ ]范围内的偶数都能取到，这时分类讨论就可以 $O(1)$ 判断。\n  * 其余情况，都能证明剩下的数组成的最小和到最大和的每个数都可以取到，同样也可以在 $O(n)$ 判断。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nchar s[maxn];\nint cnt[3];\nbool check(int mn,int mx,int now){\n\tif(now%3==0){\n\t\tif(mx%3==1){\n\t\t\tif(mx-4>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==0){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(mx%3==2){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(now%3==1){\n\t\tif(mx%3==1){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==0){\n\t\t\tif(mx-4>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse return 1;\n\t}\n\telse{\n\t\tif(mx%3==0){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==2){\n\t\t\tif(mx-4>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse return 1;\n\t}\n\treturn 0;\n}\nbool check2(int mn,int mx,int now){\n\tif(now%3==0){\n\t\tif(mx%3==1){\n\t\t\tif(mx-1>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==0){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(mx%3==2){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(now%3==1){\n\t\tif(mx%3==1){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==0){\n\t\t\tif(mx-1>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse return 1;\n\t}\n\telse{\n\t\tif(mx%3==0){\n\t\t\tif(mx-2>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(mx%3==2){\n\t\t\tif(mx-1>=mn){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse return 1;\n\t}\n\treturn 0;\n}\nint calmx(int cnt0,int cnt1,int cnt2,int res){\n\tint ans=0;\n\tif(cnt2>=res){\n\t\treturn res*2;\n\t}\n\telse{\n\t\tres-=cnt2;\n\t\tans+=cnt2*2;\n\t\tif(cnt1>=res){\n\t\t\treturn ans+res;\n\t\t}\n\t\telse{\n\t\t\tres-=cnt1;\n\t\t\tans+=cnt1;\n\t\t\treturn ans;\n\t\t}\n\t}\n}\nint calmn(int cnt0,int cnt1,int cnt2,int res){\n\tint ans=0;\n\tif(cnt0>=res){\n\t\treturn 0;\n\t}\n\telse{\n\t\tres-=cnt0;\n\t\tif(cnt1>=res){\n\t\t\treturn ans+res;\n\t\t}\n\t\telse{\n\t\t\tres-=cnt1;\n\t\t\tans+=cnt1;\n\t\t\treturn ans+res*2;\n\t\t}\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n,k;\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tscanf(\"%s\",s);\n\t\tcnt[0]=cnt[1]=cnt[2]=0;\n\t\tint yes=0;\n\t\tif(k==n-1){\n\t\t\tfor(int i=0;s[i];i++){\n\t\t\t\tint now=s[i]-'0';\n\t\t\t\tif(now%3==0){\n\t\t\t\t\tyes=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(yes){\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;s[i];i++){\n\t\t\tint now=s[i]-'0';\n\t\t\tcnt[now%3]++;\n\t\t}\n\t\tfor(int i=0;s[i];i++){\n\t\t\tint now=s[i]-'0';\n\t\t\tcnt[now%3]--;\n\t\t\tn--;\n\t\t\tint res=n-(k-i);\n\t\t\tif(now==0) continue;\n\t\t\telse if(i>k) break;\n\t\t\telse{\n\t\t\t\tif(cnt[0]&&!cnt[1]&&!cnt[2]){\n\t\t\t\t\tif(now%3==0){\n\t\t\t\t\t\tyes=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cnt[1]&&!cnt[0]&&!cnt[2]){\n\t\t\t\t\tif((res+now)%3==0){\n\t\t\t\t\t\tyes=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cnt[2]&&!cnt[1]&&!cnt[0]){\n\t\t\t\t\tif((res*2+now)%3==0){\n\t\t\t\t\t\tyes=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cnt[2]&&cnt[0]&&!cnt[1]){\n\t\t\t\t\tint mx=cnt[2]>=res?res*2:cnt[2]*2;\n\t\t\t\t\tint mn=cnt[0]>=res?0:(res-cnt[0])*2;\n\t\t\t\t\tyes|=check(mn,mx,now);\n\t\t\t\t\tif(yes) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint mx=calmx(cnt[0],cnt[1],cnt[2],res);\n\t\t\t\t\tint mn=calmn(cnt[0],cnt[1],cnt[2],res);\n\t\t\t\t\tyes|=check2(mn,mx,now);\n\t\t\t\t\tif(yes) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(yes) printf(\"yes\\n\");\n\t\telse printf(\"no\\n\");\n\t}\n} \n```\n\n\n\n#### C\n\n* 大致题意：给定两个数组 $a$ 和 $b$ ，要求计算：\n  $$\n  \\min\\{\\sum_{i=0}^{n-1}(A_i-B_{(i+k)\\bmod n})^2|k=0,1……n-1\\}\n  $$\n\n* 大致题解：把这个式子写几项出来，就会发现，每个式子中都存在 $\\sum a^2$ 和 $\\sum b^2$ ，不一样的只是 $\\sum ab$ 的形式，大概类型如下：\n  $$\n  a_0*b_0+a_1*b_1+……+a_{n-1}*b_{n-1}\\\\\n  a_0*b_1+a_1*b_2+……+a_{n-1}*b_{0}\\\\\n  ……\\\\\n  a_0*b_{n-1}+a_1*b_{0}+……+a_{n-1}*b_{n-2}\n  $$\n  可以发现这些式子都可以写成卷积的形式，基本上都可以拆成 a 的倒序数组和 b 以及 b 的倒序数组和 a 的卷积，之后用 $fft$ 处理即可，但是这题比较恶心，$fft$ 精度不高，这题卡了 $fft$ 精度，不过这题只需要直到各个式子之间的相对大小，所以只要算出偏移量就行了，然后模拟一下就可以解决。\n\n```c++\n#include <bits/stdc++.h>//快速傅里叶变换(fast-fast-tle) \nusing namespace std;\ntypedef long long ll;\nconst int maxn=3e5+13;\ntypedef long long ll;\nconst double pi=acos(-1.0);\nint len=1,pos[maxn];\nint ans[maxn];\ndouble aa[maxn],bb[maxn];\nll ansa[maxn],ansb[maxn];\nstruct cpx{\n\tdouble a,b;\n\tcpx(double x=0.0,double y=0.0) \n\t{\n\t\ta=x,b=y;\n\t}\n\tcpx operator-(cpx &x) {return cpx(a-x.a,b-x.b);}\n\tcpx operator+(cpx &x) {return cpx(a+x.a,b+x.b);}\n\tcpx operator*(cpx &x) {return cpx(x.a*a-x.b*b,a*x.b+b*x.a);} \n}a[maxn],b[maxn],c[maxn],d[maxn],e[maxn],f[maxn];\nvoid ini()//对原式子做蝴蝶变换的辅助 \n{\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tpos[i]=pos[i>>1]>>1;\n\t\tif(i&1) pos[i]|=(len>>1);\n\t}\n}\nvoid fft(cpx x[],int on)//快速傅里叶变换主部分 \n{\n\tfor(int i=0;i<len;i++) if(i<pos[i]) swap(x[i],x[pos[i]]);\n\tfor(int i=2;i<=len;i<<=1)\n\t{\n\t\tint step=i>>1;\n\t    cpx wm(cos(2*pi/(double)i),sin(2*pi*on/(double)i));\n\t    for(int j=0;j<len;j+=i)\n\t\t{\n\t\t\tint mx=j+step;\n\t\t\tcpx now(1,0);\n\t\t\tfor(int k=j;k<mx;k++)\n\t\t\t{\n\t\t\t\tcpx aa=x[k],bb=x[k+step]*now; \n\t\t\t\tnow=now*wm;\n\t\t\t\tx[k]=aa+bb;\n\t\t\t\tx[k+step]=aa-bb;//对于两个数now互为相反，所以取a-b \n\t\t\t}\n\t\t } \n\t}\n\tif(on==-1) for(int i=0;i<len;i++) x[i].a/=(double)len; \n}\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint sum=n+n+1;\n\tlen=1; \n\twhile(len<sum) len<<=1; \n\tfor(int i=0;i<len;i++){\n\t\ta[i].a=b[i].a=c[i].a=d[i].a=e[i].a=f[i].a=0;\n\t\ta[i].b=b[i].b=c[i].b=d[i].b=e[i].b=f[i].b=0;\n\t}\n\tfor(int i=0;i<n;i++) scanf(\"%lf\",&aa[i]);\n\tfor(int i=0;i<n;i++) scanf(\"%lf\",&bb[i]);\n\tfor(int i=0;i<n;i++) a[i].a=aa[i];\n\tfor(int i=n-1;i>=0;i--) b[n-1-i].a=bb[i];\n\tfor(int i=n-1;i>=0;i--) c[n-1-i].a=aa[i];\n\tfor(int i=0;i<n;i++) d[i].a=bb[i];\n\tini();\n\tfft(a,1);\n\tfft(b,1);\n\tfor(int i=0;i<len;i++) e[i]=a[i]*b[i];\n\tfft(e,-1);\n\tfor(int i=0;i<len;i++) ansa[i]=(ll)(e[i].a+0.5);\n\tfft(c,1);\n\tfft(d,1);\n\tfor(int i=0;i<len;i++) f[i]=c[i]*d[i];\n\tfft(f,-1);\n\tfor(int i=0;i<len;i++) ansb[i]=(ll)(f[i].a+0.5);\n\tll mx=0;\n\tint pos=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i==n-1){\n\t\t\tif(ansa[i]>mx){\n\t\t\t\tmx=ansa[i];\n\t\t\t\tpos=0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(ansa[i]+ansb[n-2-i]>mx){\n\t\t\t\tmx=ansa[i]+ansb[n-2-i];\n\t\t\t\tpos=n-1-i;\n\t\t\t}\n\t\t}\n\t} \n\tll ans=0;\n\tfor(int i=0;i<n;i++) ans+=(ll)(aa[i]*aa[i]);\n\tfor(int i=0;i<n;i++) ans+=(ll)(bb[i]*bb[i]);\n\tfor(int i=0;i<n;i++){\n\t\tans-=2*(ll)(aa[i]*bb[(i+pos)%n]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    }\n } \n```\n\n\n\n#### D\n\n* 大致题意：有一张 $n*20$ 的棋盘，上面有一些棋子，两个做博弈，每次一个人可以选择一行移动该行上的棋子，向前移动，规定如果前面已经有棋子需要越过去直到碰到第一个没有棋子的空格，但是不能跳出边界，什么操作都做不了的人赢，问最后谁会获胜。\n\n* 大致题解：基本上是一道 $SG$ 函数的模板题，$SG$ 定理规定，对于多重游戏组合的状态，如果游戏 $X$ 可以看作 $n$ 个游戏的复合，那么\n  $$\n  SG_X = SG_{X_1} \\oplus SG_{X_2} \\oplus SG_{X_3}……\\oplus SG_{X_n}\n  $$\n  如果 $SG_{X}$ 为 $0$ 则先手必输，否则先手必赢。之后对于每一行直接进行搜索，需要状压+记忆化状态。\n\n```c++\n#include <bits/stdc++.h>//SG函数 \nusing namespace std;\nconst int maxn=1e6+1e5;\nint sv[maxn];\nint dfs(int now){\n\tint vis[35],mex=0,cun=now;\n\tfor(int i=0;i<=30;i++) vis[i]=0;\n    for(int i=1;i<=20;i++){\n    \tif((now>>(i-1))&1){\n    \t\tint st=i;\n    \t\twhile(((now>>(st-1))&1)&&st<=20) st++;\n    \t\tif(st<=20){\n    \t\t\tnow^=(1<<(i-1));\n    \t\t\tnow|=(1<<(st-1));\n    \t\t\tif(~sv[now]){\n    \t\t\t\tvis[sv[now]]=1;\n\t\t\t\t}\n\t\t\t\telse vis[dfs(now)]=1;\n    \t\t\tnow=cun;\n\t\t\t}\n\t\t}\n\t}\n\twhile(vis[mex]) mex++;\n\treturn sv[now]=mex;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\tmemset(sv,-1,sizeof(sv));\n\twhile(t--){\n\t\tint n,ans=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint m,p,st=0;\n\t\t\tscanf(\"%d\",&m);\n\t\t\tfor(int j=1;j<=m;j++) scanf(\"%d\",&p),st|=(1<<(p-1));\n\t\t\tif(~sv[st]) ans^=sv[st];\n\t\t\telse ans^=dfs(st);\n\t\t}\n\t\tif(ans) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n} \n```\n\n\n\n### E\n\n* 大致题意：需要输出 $m$ 个字符，列出了每个字符出现的概率，第 $i$ 个字符出现的概率为 $p_i$ ，还给出了字符串 $s$ ，问最终得到的字符串中含有 $s$ 的概率是多少？\n\n* 题解：基本思路是要 $dp$ ，枚举从一个字符串向另个字符串转移时状态的变化，然后实时的对产生的字符串做字符串匹配，要做字符串匹配就想到要建状态机，适用于匹配的状态机，也就 $kmp$，和 $ac$ 自动机，这里都可以做，但是选则 $ac$ 自动机更加方便，因为建出$ac$ 自动机后 $ch[i][j]$ 相当于从状态 $i $ 转移到状态 $j$ ，将 $kmp$ 跳完 $fail$ 边之后转移后的结果，而且这里只有一个串，字典数上的节点其实也就是一一对应了串上每个前缀的长度。所以很容列出 $dp$ 方程。\n  $$\n  dp[i+1][vv]+=dp[i][j]*v[z]\n  $$\n  $vv$ 表示由 $j$ 转移到 $z$ 时达到的状态。$i$ 表示当前处理到第几个字符，$\\sum_{i=0}^mdp[i][len]$ 即是答案。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+13;\nqueue<int> q;\nint ch[maxn][26],fail[maxn];\nchar s[maxn];\nint cnt=0,p=0;\ndouble v[maxn];\ndouble dp[maxn][50];\nvoid insert(char *s)\n{\n\tint rt=0;\n\tfor(int i=0;s[i]!='\\0';i++)\n\t{\n\t\tint lo=s[i]-'a';\n\t\tif(!ch[rt][lo]) ch[rt][lo]=++p;\n\t\trt=ch[rt][lo];\n\t}\n}\nvoid pre_ac()\n{\n\tint rt=0;\n\tfor(int i=0;i<=25;i++)\n\t{\n\t\tif(ch[rt][i]) q.push(ch[rt][i]);\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tif(ch[now][i])\n\t\t\t{\n\t\t\t\tfail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tch[now][i]=ch[fail[now]][i];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint n,m;\n\tdouble w;\n\tchar tt[5];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%s%lf\",tt,&w);\n\t\t\tv[tt[0]-'a']=w;\n\t\t}\n\t\tscanf(\"%s\",s);\n\t\tint len=strlen(s);\n\t\tp=0;\n\t\tinsert(s);\n\t\tpre_ac();\n\t\tdp[0][0]=1.0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tfor(int z=0;z<26;z++){\n\t\t\t\t    int vv=ch[j][z];\n\t\t\t\t    dp[i+1][vv]+=dp[i][j]*v[z];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=0;\n\t\tfor(int i=0;i<=m;i++) ans+=dp[i][len];\n\t\tprintf(\"%.2lf%%\\n\",ans*100.0);\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=p;i++){\n\t\t\tfail[i]=0;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tch[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++) v[i]=0;//clear\n\t}\n} \n```\n\n","tags":["2021寒假训练"],"categories":["算法","刷题"]},{"title":"CF edu 105","url":"/2021/03/04/CF-edu-105/","content":"\n## codeforces educational round 105\n\n<!--more-->\n\n### C\n\n* 大致题意：有好多个箱子，也有好多个箱子目标点，全部排列在 $x$ 轴上，现在人站在 $0$ 点，规定人可以向左向右走，遇到箱子后，如果箱子堵在前进方向上，则人前进的同时也会推动箱子和自己一起走同时一个后面的箱子可以推动前面的箱子，但是人不能超过任何一个挡在前面的箱子，问最多能让多少箱子停在目标点？\n* 题解：向左向右走明显是等价的，可以用同一种方法解决，对于一边，考虑到后面的情况，人会推着一大堆箱子走，每次最优的情况明显是，被推动的箱子停在目标点。可以枚举目标点，每次枚举人推着这些箱子走到这个目标点（除非目标点处原本就有箱子），二分查找这个目标点之前有多少个箱子，以及这些箱子队列覆盖了多少目标点。还需要预处理出一开始目标点和箱子位置就重合的个数前缀和，随着箱子的推进减少它的贡献。其实主要还是看码的技巧了……，还有就是对一个 $vector$ 进行 $lowerbound$ 和$upperbound$操作实际上是返回的是下标，不是数量……。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+13;\nstruct node{\n\tint val,i,j;\n}tt[maxn];\nint fa[maxn],ans[maxn],f[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nbool cmp(node a,node b){\n    if(a.val==b.val){\n    \treturn a.i==b.i?a.j<b.j:a.i<b.i;\n\t}\n\telse return a.val<b.val;\n}\nint main(){\n\tint n,x;\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(i==j) ans[i]=x,fa[i]=i;\n\t\t\telse{\n\t\t\t    tt[++cnt]=(node){x,i,j};\t\n\t\t\t}\n\t\t}\n\t}\n\tsort(tt+1,tt+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++){\n\t\tint f1=find(tt[i].i),f2=find(tt[i].j),now=tt[i].val;\n\t\tif(f1==f2) continue;\n\t\tif(max(ans[f1],ans[f2])==now){\n\t\t\tif(ans[f1]>ans[f2]){\n\t\t\t\tfa[f2]=f1;\n\t\t\t\tf[f2]=f1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfa[f1]=f2;\n\t\t\t\tf[f1]=f2;\n\t\t\t}\n\t\t}\n\t\telse if(max(ans[f1],ans[f2])<now){\n\t\t\tn++;\n\t\t\tfa[n]=n;\n\t\t\tf[f1]=f[f2]=n;\n\t\t\tfa[f1]=fa[f2]=n;\n\t\t\tans[n]=now;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\tint rt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(find(i)==i){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",rt);\n\tfor(int i=1;i<=n;i++){\n\t\tif(i!=rt){\n\t\t\tprintf(\"%d %d\\n\",i,f[i]);\n\t\t}\n\t}\n}\n```\n\n### D\n\n* 大致题意：给了一些叶子节点，和叶子节点之间两两的 $lca$ 的权值，规定父节点的权值严格大于子节点，要求还原这棵树。\n* 题解：由于父节点权值严格大于子节点，所以可以认为权值越小的点深度越大，所以可以考虑将所有权值从小到大排列，从下往上用并查集合并，每次按上述排序后的顺序访问点对，如果两个点在一个并查集中，说明根节点被申明过，所以根节点一定不会是他们的直系父亲，如果两个点不在一个并查集中，查询两个并查集的根节点，只存在两种情况，现在访问到的权值和两个根节点的权值较大值相等，那么肯定是一个根节点是另一个的父亲，否则，就存在一个未被申明过的直系父亲，构造新点然后合并两个集合即可。注意合并新点时候应该按照 $(i,j)$ 从小到大和并，否则，会出问题，比如 $1,2,3,4$ 同时属于 $5$ ，先合并了 $1,2$，再合并了 $3,4$ ，就会多出一个点。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+13;\nstruct node{\n\tint val,i,j;\n}tt[maxn];\nint fa[maxn],ans[maxn],f[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nbool cmp(node a,node b){\n    if(a.val==b.val){\n    \treturn a.i==b.i?a.j<b.j:a.i<b.i;\n\t}\n\telse return a.val<b.val;\n}\nint main(){\n\tint n,x;\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(i==j) ans[i]=x,fa[i]=i;\n\t\t\telse{\n\t\t\t    tt[++cnt]=(node){x,i,j};\t\n\t\t\t}\n\t\t}\n\t}\n\tsort(tt+1,tt+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++){\n\t\tint f1=find(tt[i].i),f2=find(tt[i].j),now=tt[i].val;\n\t\tif(f1==f2) continue;\n\t\tif(max(ans[f1],ans[f2])==now){\n\t\t\tif(ans[f1]>ans[f2]){\n\t\t\t\tfa[f2]=f1;\n\t\t\t\tf[f2]=f1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfa[f1]=f2;\n\t\t\t\tf[f1]=f2;\n\t\t\t}\n\t\t}\n\t\telse if(max(ans[f1],ans[f2])<now){\n\t\t\tn++;\n\t\t\tfa[n]=n;\n\t\t\tf[f1]=f[f2]=n;\n\t\t\tfa[f1]=fa[f2]=n;\n\t\t\tans[n]=now;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\tint rt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(find(i)==i){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",rt);\n\tfor(int i=1;i<=n;i++){\n\t\tif(i!=rt){\n\t\t\tprintf(\"%d %d\\n\",i,f[i]);\n\t\t}\n\t}\n}\n```\n\n### E\n\n* 大致题解：一开始是一张只有 $n$ 个点的空图，存在三种操作，在点 $u$ 和点 $v$ 之间增加一条权值为 $c$ 的有向边，去掉一条连接 $u,v$ 的有向边，和查询是否存在一条经过 $k$ 个点的路径满足正着走得到的边的序列和倒着走得到的边的序列相同。\n* 题解：对于 $k$ 为奇数的情况，只要查询是否存在两个点 $u,v$ ，$u$ 到 $v$ 和 $v$ 到 $u$ 都有一条有向边，因为有 $u-v-u$ 翻转过来和原本相同，对于 $k$ 为偶数数的情况，查询是否存在两个点 $u,v$ ，$u$ 到 $v$ 和 $v$ 到 $u$ 都有一条权值相同的有向边，充分性显然的，必要性也显然。用 $map$ 维护一下即可。","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"Global round 13","url":"/2021/03/02/Global-round-13/","content":"\n## codeforces Global round 13\n\n<!--more-->\n\n### C\n\n* 大致题意：给出 $n$ 个数，一只兔子在这些数上跳来跳去，每轮跳这只兔子可以随意选择一个位置，从这个位置开始跳，兔子每到达一个数，这个数就会自减 $1$ 直到这个数变为 $1$ ，如果当前兔子到达数字 $a_i$ ，则兔子下一个会到达位置 $i+a_i$ 。问至少跳多少次才会让所有数字都变为 $1$ 。\n* 题解：对于任意一个数字 $a_i$ ，当前兔子在 $i$ 这个位置时，下一步兔子会前进 $a_i$ ，之后兔子再到达 $i$ 这个位置时，只会再前进 $a_i-1$ 个位置，以此类推，直到变为 $1$ 为止，会对这个位置之后 $1,2……a_i-1$ 的位置产生贡献。让每个数变为 $1$ 是必要的条件，不妨这么考虑，再将一个数削成 $1$ 的过程中，肯定是优先使用之前的数字跳到这的情况，所以可以用 $dp[i]$ 表示前面的位置对这个位置产生的情况贡献，对每个位置，优先使用 $dp[i]$ 来将这些数字消为 $1$ ，如果不够 $(dp[i]<0)$ 就用答案计入。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=5013;\nint a[maxn];\nll dp[maxn];//存跳的机会 \nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),dp[i]=0;\n\t\tll ans=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==n){\n\t\t\t\tdp[i]-=a[i]-1;\n\t\t\t\tans+=max(-dp[i],1ll*0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i+a[i]>n) dp[i]-=1ll*(i+a[i]-n); \n\t\t\t\tfor(int j=2;j<=a[i];j++){\n\t\t\t\t\tif(i+j>n) break;\n\t\t\t\t\tdp[i+j]++;//给它跳的机会\n\t\t\t\t\tdp[i]--;//代价是自己跳的机会减少 \n\t\t\t\t}\n\t\t\t\tans+=max(-dp[i],1ll*0);\n\t\t\t\tif(dp[i]>0) dp[i+1]+=dp[i];\n\t\t\t} \n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n} \n```\n\n### D\n\n* 大致题意：由所有正整数组成的一张无限大的图，从 $u$ 向 $u+v$ 连一条有向边当且仅当$u\\&v=v$  ，现在存在 $m$ 次询问，每次给出 $u,v$ 问点 $u$ 和点 $v$ 是否连通。\n* 题解：点 $u$ 和点 $v$ 联通的充要条件是对于二进制表示状态的 $u$ 和 $v$ 的每个后缀 $1$ 的数量和都满足 $sum_u\\ge sum_v$ ，感性的证明一下就是，如果 $u$ 的某一位为 $0$ ，那么 $v$ 的这一位必定是 $0$ ，加出来的结果是 $0$ ，如果 $u$ 的某一位是 $1$ ，那么 $v$ 的这一位是 $0$ 或者 $1$ ，加起来就是 $1$ 或者进位的基础上为 $0$ ，可以发现一个规律，从 $u$ 到 $u+v$ 后缀 $1$ 的和不会比原来的多，因为原本的 $u$ 对应位置的 $1$ 都向前移动了，且总 $1$ 的个数不会减少。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tif(u>v){\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t\telse{\n\t\t    int yes=1,ans=0;\n\t\t    for(int i=0;i<=30;i++){\n\t\t    \tif((u>>i)&1) ans+=1;\n\t\t    \tif((v>>i)&1) ans-=1;\n\t\t    \tif(ans<0){\n\t\t    \t\tyes=0;\n\t\t    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(yes?\"YES\\n\":\"NO\\n\");\n\t\t}\n\t}\n} \n```\n\n### E\n\n* 大致题意：定义\"斐波那契树\"为一颗树满足，树的节点数为斐波那契数，该树通过删去树上一条边，可以使这颗树成为两棵\"斐波那契树\"。给定一颗树，问这颗树是否使\"斐波那契树\"？\n* 题解：直接暴力对树 $dfs$ 找到一颗子树的大小为斐波那契数即可，可以发现，每次都能将数分解成两棵树，由于斐波那契数列越往后面，两个相邻斐波那契数的比越接近黄金比，而黄金比保证了较大的数不会超过较小的数的两倍，所以每次树缩小的量使接近一半的，整体缩小次数是 $log$ 级别的，每次只会 $dfs$ 现在剩下的树，所以复杂度是对的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+13;\nvector<pair<int,bool> > p[maxn];\nint vis[maxn];\nint sz[maxn];\nint rt1,rt2,pos;\nvoid find(int rt,int f,int k){\n\tsz[rt]=1;\n\tfor(int i=0;i<p[rt].size();i++){\n\t\tint v=p[rt][i].first;\n\t\tif(p[rt][i].second||v==f) continue;\n\t\tfind(v,rt,k);\n\t\tsz[rt]+=sz[v];\n\t\tif((vis[sz[v]]==k-1||vis[sz[v]]==k-2)&&rt1==0){\n\t\t\tif(vis[sz[v]]==k-1){\n\t\t\t\trt1=v;\n\t\t\t\trt2=rt;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trt1=rt;\n\t\t\t\trt2=v;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\nbool check(int rt,int k){\n\tif(k<=2) return true;\n    rt1=rt2=0;\n    find(rt,0,k);\n    if(!rt1) return false;\n    for(int i=0;i<p[rt1].size();i++){\n    \tif(p[rt1][i].first==rt2){\n    \t\tp[rt1][i].second=true;\n\t\t}\n\t}\n\tfor(int i=0;i<p[rt2].size();i++){\n    \tif(p[rt2][i].first==rt1){\n    \t\tp[rt2][i].second=true;\n\t\t}\n\t}\n\tint fi=rt1,se=rt2;\n\treturn check(fi,k-1)&check(se,k-2);\n}\nint main(){\n\tint n;\n\tint a=1,b=1,tp=0;\n\tvis[1]=2;\n\tfor(int i=3;tp<=200000;i++){\n\t\ttp=a+b;\n\t\tvis[tp]=i;\n\t\tb=a;\n\t\ta=tp;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tp[u].push_back({v,false});\n\t\tp[v].push_back({u,false});\n\t}\n\tif(vis[n]==0) printf(\"No\");\n\telse{\n\t\tif(check(1,vis[n])){\n\t\t\tprintf(\"Yes\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"No\");\n\t\t}\n\t}\n}\n```\n\n### F\n\n* 大致题意：交互题，有 $n$ 个磁铁，这 $n$ 个磁铁中存在一些 $N$ 极，存在一些 $S$ 极，存在一些无磁性磁铁，定义一个磁性检测机器，有两个托盘，可以选择一些磁铁放在左边，一些放在右边，定义评分为 $n_1n_2+s_1s_2-n_1s_2-n_2s_1$ 用 $n_1$ $s_1$ 和 $n_2 s_2$ 表示左边的磁铁的$N$ 极 $S$ 极的数量和右边的磁铁的$N$ 极 $S$ 极的数量， 对于每次询问，可以选择两组磁铁放上去检验，返回的是评分，要求在不超过 $n +\\log n$ 次询问下找出所有的无磁极磁铁（保证有磁极磁铁大于等于 $2$）。\n\n* 题解：关于 $n_1n_2+s_1s_2-n_1s_2-n_2s_1$ 这个式子可以很容易看出来可以直接因式分解成 $(n_1-s_1)(n_2-s_2)$ ，也就是每个部分的 $N$ 极数量和 $S$ 极数量差。显然，假如找到了一个有磁极的磁铁，它的位置为 $i$ ，那么可以很容易找到位置 $i$ 之后的所有无磁极磁铁。可以从小到大采取如下策略，每次选取 $1,2……i-1$ 和 $i$ $(i\\ge2)$ ，直到第一次得到非$0$ 的答案，正确性显然，而且这样找出来的是第二个有磁极磁铁。按上面所述，总共不超过 $n$ 次询问可以处理完第二个有磁极磁铁之后的情况，之后考虑第一个有磁极磁铁，看还差 $\\log n$ 次，一看就是二分，二分区间看包不包含有磁极磁铁即可，用前面求得的位置 $i$ ，每次询问二分区间和 $i$ 看结果是否是 $0$ 即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ans;\nint pos,now;\nbool check(int l,int r){\n\tprintf(\"? %d %d\\n\",r-l+1,1);\n\tfflush(stdout);\n\tfor(int j=l;j<=r;j++) printf(\"%d \",j);\n\tputs(\"\");\n\tfflush(stdout);\n\tprintf(\"%d\\n\",pos);\n\tfflush(stdout);\n\tscanf(\"%d\",&now); \n\tif(now){\n\t\treturn true;\n\t}\n\telse return false;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tans.clear();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tprintf(\"? %d %d\\n\",i-1,1);\n\t\t\tfflush(stdout);\n\t\t\tfor(int j=1;j<i;j++) printf(\"%d \",j);\n\t\t\tputs(\"\");\n\t\t\tfflush(stdout);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\tfflush(stdout);\n\t\t\tscanf(\"%d\",&now);\n\t\t\tif(now){\n\t\t\t\tpos=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=pos+1;i<=n;i++){\n\t\t\tprintf(\"? %d %d\\n\",1,1);\n\t\t\tfflush(stdout);\n\t\t\tprintf(\"%d\\n\",pos);\n\t\t\tfflush(stdout);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\tfflush(stdout);\n\t\t\tscanf(\"%d\",&now);\n\t\t\tif(!now){\n\t\t\t\tans.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint l=1,r=pos-1;\n\t\twhile(l<r){\n\t\t\tint mid=l+r>>1;\n\t\t\tif(check(l,mid)) r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tfor(int i=1;i<=pos-1;i++){\n\t\t\tif(i!=l) ans.push_back(i);\n\t\t}\n\t\tsort(ans.begin(),ans.end());\n\t\tprintf(\"! %d \",ans.size());\n\t\tfor(int i=0;i<ans.size();i++) printf(\"%d \",ans[i]);\n\t\tputs(\"\");\n\t\tfflush(stdout);\n\t}\n} \n```\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"近期题目整理 atcoder","url":"/2021/03/01/近期题目整理-atcoder/","content":"\n> 鸽子的灌水之atcoder\n\n<!--more-->\n\n### ARC112-C\n\n* 大致题意：给出一颗树，初始每一个点都有一个硬币，两个人轮流做游戏，在每一局中如果当前节点有一个硬币，当前操作玩家得到一个硬币，否则，当前操作玩家需要选择一个当前节点的一个存在硬币的子节点，移动到那个字节上然后结束操作。如果子节点中没有硬币了就移动到当前节点父节点结束操作，如果每个人都按照最优策略做，问最后结束操作后，两个人每个人手中各有多少硬币。\n* 题解：首先有一个规律就是，在选择子树的时候，如过选择的子树的大小为偶数，那么在回到节点后在进行一次选择的人还是原来的人，直到偶数子树全部都被选完为止。用 $dp[i]$ 表示从 $i$ 开始遍历 $i$ 节点的子树，先手拿硬币，后手选择子树的情况下，先手能比后手多拿的硬币数量。对于当前节点的每一个偶数大小子树，作为后手，一定会一次性选完所有满足 $dp[v]<0$ 的子节点让 $dp[i]$ 变得尽可能的小，对于每一个奇数大小子树，每选一次就需要交换一次操作者，而且先手进入子树的情况下，对 $dp[i]$ 的贡献是 $-dp[v]$（因为先手和后手会交换） ，后手进入子树，对 $dp[i]$ 的贡献就是 $dp[v]$，而先手希望 $dp[i]$ 变大，后手希望 $dp[i]$ 变小，所以只要将奇数大小子树 $dp$ 值从小到大排序后依次取即可。最后剩下一种情况，就是偶数大小子树且 $dp[v]\\ge0$ ，这种情况下，无论先手选还是后手选都会使他们吃亏，所以统计和之后，直接把这个数塞到最后，枚举到谁就是谁的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nvector<int> p[maxn];\nint dp[maxn],sz[maxn];\nvoid dfs(int x,int f){\n\tvector<int> rb;\n\tdp[x]=1;//后手选择，先手比后手多的 \n\tsz[x]=1;\n\tint sum=0;\n\tfor(int i=0;i<p[x].size();i++){\n\t\tint v=p[x][i];\n\t\tif(v==f) continue;\n\t\tdfs(v,x);\n\t\tsz[x]+=sz[v];\n\t\tif(sz[v]&1) rb.push_back(dp[v]);\n\t\telse{\n\t\t\tif(dp[v]<0) dp[x]+=dp[v];\n\t\t\telse  sum+=dp[v];\n\t\t}\n\t}\n\tsort(rb.begin(),rb.end());\n\trb.push_back(sum);//没人要所以只能放在最后 \n\tfor(int i=0;i<rb.size();i++){\n\t\tif(i&1) dp[x]-=rb[i];//若先手进入则值需要反过来 \n\t\telse dp[x]+=rb[i];\n\t}\n}\nint main()\n{\n\tint n,ff;\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%d\",&ff);\n\t\tp[ff].push_back(i);\n\t\tp[i].push_back(ff);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",(dp[1]+n)/2);\n}\n```\n\n### ARC112 D\n\n* 大致题意：给定一个 $H$ 行，$W$ 列的点阵，中间夹杂一些 # 符号，规定从一个点出发，可以向四个方向移动直到触碰到边界或者 # 号，从一个 # 号可以再次选择一个方向继续移动，直到再次碰壁，问至少还要增加多少 # 才能满足从一个点出发能够到达所有其他的点？\n* 题解：首先，如果能到达一行或者一列（并且能够停在这一行或者这一列），那么这一行这一列的所有点都能到，所以考虑连接所有的行和列，一开始会发现，第一行最后一行第一列最后一列都是相互联通的，不妨用并查集维护，不难发现 $(i,j)$ 处有一个 # 代表的含义是 $i$ 行和 $j$ 列是联通的，实际上只要保证所有行都在一个并查集中，或者所有列都在一个并查集中，就能够保证整张图联通，而且对于两个联通块，一定能通过在边界处增加一个 # 使它们联通，所以只要计算一下行连通块和列联通块的最小值减一即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=6000;\nint fa[maxn];\nchar s[1033][1033];\nint vis[maxn];\nvector<int> rb;\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nvoid merge(int x,int y){\n\tint f1=find(x),f2=find(y);\n\tif(f1==f2) return;\n\tfa[f1]=f2;\n}\nint main()\n{\n    int h,w;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=1;i<=h;i++){\n\t\tscanf(\"%s\",s[i]+1);\n\t}\n\tfor(int i=1;i<=h+w;i++) fa[i]=i;\n\tmerge(1,1+h);\n\tmerge(1,h+w);\n\tmerge(h,h+1);\n\tmerge(h,h+w);\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(s[i][j]=='#') merge(i,j+h);\n\t\t}\n\t}\n\tint ans=0,end=1e9;\n\tfor(int i=1;i<=h;i++){\n\t\tint f=find(i);\n\t\tif(vis[f]) continue;\n\t\telse vis[f]=1,ans++;\n\t}\n\tend=min(end,ans-1);\n\tmemset(vis,0,sizeof(vis));\n\tans=0;\n\tfor(int i=1;i<=w;i++){\n\t\tint f=find(h+i);\n\t\tif(vis[f]) continue;\n\t\telse vis[f]=1,ans++;\n\t}\n\tend=min(end,ans-1);\n\tprintf(\"%d\",end);\n}\n```\n\n### ABC192 D\n\n* 大致题意：给定一个有 $0-9$ 组成的数字字符串，长度不超过 $60$，令其中最大的字符为$d$ ,问有多少个 $n$ 满足将该数字看作 $n$ 进制后表示的数小于等于 $m$ ，其中（$n\\ge d+1$）。\n* 题解： 随着 $n$ 的增大，表示的数字也会不断变大，所以直接二分进制数即可，注意特判长度为 $1$ 以及一开始就不成立的情况。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e6+13;\nchar s[300];\nll m;\nbool check(ll x){\n\t__int128 now=0;\n\tfor(int i=1;s[i];i++){\n\t\tnow=now*x+s[i]-'0';\n\t\tif(now>m) return 0;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld\",&m);\n\tint len=strlen(s+1);\n\tif(len==1){\n\t\treturn printf(\"%d\",(s[1]-'0'<=m)),0;\n\t}\n\tint mx=0;\n\tfor(int i=1;i<=len;i++) mx=max(mx,s[i]-'0');\n\tif(!check(mx+1)){\n\t\treturn printf(\"0\"),0;\n\t}\n\tll l=1,r=m;\n\tll ans=0;\n\twhile(l<=r){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t} \n\tprintf(\"%lld\",ans-mx);\n } \n```\n\n### ABC192 F\n\n* 大致题意：有 $n$ 个数，从中选择 $k$ 个数后，得到一个和，之后每过一秒钟，这个和都会上升 $k$ ，问最早什么时候能够使这个和正好变成 $x$ 。\n\n* 题解：用 $dp[i][j][k]$ 表示在前 $i$ 个数中选 $j$ 个，最后得到的和模选择的个数为 $k$ 的最大值，然后枚举选择的人数，之后分别枚举每个人，选择的人，模数然后做转移即可。\n  $$\n  dp[i][j][(k+a[i])\\%l] = max(dp[i-1][j-1][k]+a[i],self)\n  $$\n  对于每个人数都能得到一个最优情况，在选择 $l$ 个人的情况下的最优解就是 $\\frac{x-dp[n][l][x\\%l]}{l}$ ，之后对所有情况的最优解再取一个最小值即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=104;\ntypedef long long ll;\nll dp[maxn][maxn][maxn];//从前i个中选择j个sum%k=l的最大值 \nint a[maxn];\nvoid chmax(ll &a,ll b){\n\ta=max(a,b);\n}\nint main(){\n\tint n;\n\tll x;\n\tscanf(\"%d%lld\",&n,&x);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tll ans=1e18;\n\tfor(int k=1;k<=n;k++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][0][0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tif(!j){\n\t\t\t\t\tdp[i][j][0]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\t\tif(j&&dp[i-1][j-1][l]!=-1){\n\t\t\t\t\tchmax(dp[i][j][(l+a[i])%k],dp[i-1][j-1][l]+1ll*a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j][l]!=-1) chmax(dp[i][j][l],dp[i-1][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tif(dp[n][k][x%k]!=-1) ans=min(ans,(x-dp[n][k][x%k])/k);\n\t}\n\tprintf(\"%lld\",ans);\n} \n```\n\n### ARC113 C\n\n* 大致题意：给定一个字符串序列，每次可以进行一个操作，就是选择三个连续的字符 $s_i,s_{i+1},s_{i+2}$ ，满足 $s_i=s_{i+1} \\& s_i\\ne s_{i+2}$ ，将 $s_{i+2}$ 变成 $s_i$ ，问最多可以做这样的操作多少次？\n* 题解：不难发现，加入找到了一个满足上述条件的序列，那么一定可以把后面的字符串推平，让它们全部变成字符 $s_i$ ，考虑一种操作的策略，从右边向左边扫，遇到一个满足条件的情况就推平一次，同时记录下每个字母出现的次数，每次统计答案时候需要减去前面这个字符出现的次数，并且把记录清空，更新为现在的字符情况，这个操作可以通过 $map$ 来维护。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2e5+13;\nchar s[maxn];\nmap<int,ll> mp;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tll ans=0;\n\tint len=strlen(s+1);\n\tfor(int i=len;i;i--){\n\t\tif(s[i]==s[i-1]&&i>1){\n\t\t\tans+=1ll*(len-i);\n\t\t\tans-=mp[s[i]-'a'];\n\t\t\tmp.clear();\n\t\t\tmp[s[i]-'a']=len-i;\n\t\t\tint st=i;\n\t\t\twhile(s[st]==s[i]&&st) mp[s[i]-'a']++,st--;\n\t\t\ti=st+1;\n\t\t}\n\t\telse mp[s[i]-'a']++;\n\t}\n\tprintf(\"%lld\",ans);\n}\n\n```\n\n### ARC113 D\n\n* 大致题意：一个大小为 $N*W$ 的矩阵，定义 $A_i,B_i$ 分别表示第 $i$ 行和第 $i$ 列的最小值和最大值，矩阵中的值的范围是 $[1,k]$ ，问 $A,B$ 所有可能的情况并对 $998244353$ 取模\n\n* 题解：其实这题只要抓住一个性质就可以了，就是 $A$ 的最大值一定小于等于 $B$ 的最小值，这个的证明只需要证明一个更加显然的性质就行，即每一行的最小值一定比任意一列的最大值小，因为每一行和每一列一定有一个数是相交的，设这个数为 $x$ ，就一定有 $min_{r} \\leq x \\leq max_l$ ，即$min_r\\leq max_l$ 。之后枚举所有行的最大值计数即可。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  const int maxn=2e5+13;\n  const int mod=998244353;\n  int fpow(int a,int b){\n  \tint ans=1;\n  \twhile(b){\n  \t\tif(b&1) ans=1ll*ans*a%mod;\n  \t\ta=1ll*a*a%mod;\n  \t\tb>>=1;\n  \t}\n  \treturn ans;\n  }\n  int main(){\n  \tint n,m,k;\n  \tscanf(\"%d%d%d\",&n,&m,&k);\n  \tif(n==1||m==1){\n  \t\tif(n==1) return printf(\"%d\",fpow(k,m)),0;\n  \t\telse return printf(\"%d\",fpow(k,n)),0;\n  \t}\n  \tint ans=0;\n      for(int i=1;i<=k;i++){\n      \tans=(ans+1ll*(fpow(i,n)-fpow(i-1,n)+mod)%mod*fpow(k-i+1,m)%mod)%mod;\n  \t}\n  \tprintf(\"%d\",ans);\n  }\n  ```\n\n  ","tags":["atcoder"],"categories":["算法","刷题"]},{"title":"近期题目整理 codeforces","url":"/2021/02/28/近期题目收集-codeforces/","content":"\n> 鸽子的灌水之codeforces\n\n<!--more -->\n\n### CF104E\n\n* 题目链接：https://codeforces.com/contest/1487/problem/E\n\n* 大致题意：有四种甜点，第 $i$ 中甜点有 $n_i$ 个，对于每种甜点的每一个都有一个不同的价格，并且规定 $3$ 种冲突，每组有 $m_i$ 个，分别表示表示第 $i$ 种甜点和第 $i+1$ 种甜点中某些冲突，即不能够同时选，现在每种甜点都要选一个组成一餐，问最少花费为多少。\n* 题解：不妨先考虑两种，假设第一种第 $i$ 个价格为 $a_i$ ，第二种第 $i$ 个价格为 $b_i$ ，对 $a$ 排序，对于每一个第二种甜点，选择一个最小且与它不冲突的第一种甜点，与这一个结合，将新生成的数作为新的 $b_i$ ，之后对于$b,c$ 和 $c,d$ 也类似处理即可。寻找最小不冲突的操作直接暴力遍历即可，保证了冲突数不超过 $1e5$ 个，所以总复杂度只是 $n+m$ ，不会爆复杂度。\n\n### CF 702G\n\n* 大致题意：给定 $n$ 个数，有 $m$ 次询问，每次询问给定一个 $x$ ，每次从第一个数开始进行循环加一个数的操作（即加完最后一个数之后回到第一个数继续操作），问多少次操作后得到的数满足大于等于 $x$ ，若永远也不会成立那么就输出 $-1$ 。\n* 题解：先处理出前缀和数组，首先可以预见的是总和小于 $0$，且前缀和数组的最大值小于$x$ 那么一定不会成立，其他情况。首先处理出最多可以循环多少次，由于序列中的数有正有负，所以可以处理出每次循环能够达到的最大贡献，也就是前缀和数组的最大值，设为 $mx$ ，设总和为 $sum$ ，不难发现 $\\lceil\\frac{x-mx}{sum}\\rceil$ 就是最多循环的次数，之后计算出剩余的数，在前缀和数组中查找第一个大于等于它的数即可，这个操作可以用ST表加二分优化到 $\\log^2 n$ ，总复杂度为 $O(mlog^2n)$\n\n\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"2021寒假训练3","url":"/2021/02/28/2021寒假训练3/","content":"\n## 寒假训练3\n\n<!-- more -->\n\n### B\n\n* 大致题意：$n$ 个人站在 $x$ 轴上，有 $m$ 对关系，每一对关系都表示 $A$ 在 $B$ 的右边距离为 $x$ 的位置。问给出的 $m$ 对关系能否自洽。\n* 题解：有一种做法是建有向图后每次标记从未遍历过的点为原点，然后 $dfs$ 出它所在的连通块中每个点的位置看是否会出现矛盾。还有一种做法，就是用带权并查集做，在普通并查集的基础上除了维护父节点外再维护一个距离数组 $dis$ ，表示并查集上距离根节点左边的距离，在访问路径压缩时合并每个点到新根的距离，每次给出的两个点如果在一个并查集里，就查询他们的距离是否满足条件即 $dis[u]-dis[v]==w$，不满足就不存在。不过这个方法明显要复杂很多。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int maxn=2e5+13;\nint x[maxn],fa[maxn];\nint dis[maxn];\nint find(int x){\n\tif(fa[x]==x) return x;\n\tint rt=find(fa[x]);\n\tdis[x]=dis[x]+dis[fa[x]];\n\treturn fa[x]=rt;\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    int yes=1;\n    for(int i=1;i<=n;i++) fa[i]=i;\n    for(int i=1;i<=m;i++){\n    \tint u,v,w;\n    \tscanf(\"%d%d%d\",&u,&v,&w);\n    \tint f1=find(u),f2=find(v);\n    \tif(f1==f2){\n    \t\tif(dis[u]-dis[v]!=w){\n    \t\tyes=0;\n    \t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfa[f1]=f2;\n\t\t\tdis[f1]=w-dis[u]+dis[v];\n\t\t}\n\t}\n\tif(!yes) printf(\"No\");\n\telse printf(\"Yes\"); \n}\n```\n\n### D\n\n* 大致题意：交互题，题目中隐藏着一个长度为 $n$ 的 $01$ 串，每次交互可以给出一个 $01$ 串，系统会返回一个数表示两 $01$ 串之间有多少位上的字符不同，询问不能超过 $15$ 次，最后要找出一个 $0$ 和 $1$ 的位置。（$n\\leq 1000$）\n* 题解：观察数据范围以及询问次数就知道大概需要二分，每次得到的两字符串之间的差异，思考如何让差异变得更加容易定性，毫无疑问可以把每次询问的字符串中的数全部设置成 $0$ 或者全部设置成 $1$ 等，一开始先把字符串中的数全设置成 $0$ ，这样询问得到的结果显然就是字符串中 $1$ 的个数，然后一段字符串中 $0，1$ 的个数一定是随着字符缩短而变少的，所以二分区间，直到区间长度为 $2$ ，每次二分到一个区间 $[l,r]$ ，将 $[l,r]$ 全部标记为$1$ 其余标记为 $0$ ，假设得到的数为 $now$ ，前面得到的 $1$ 的个数为 $num$ ，$num-now$ 表示区间 $[l,r]$ 中 $1$ 的个数减 $[l,r]$ 中 $0$ 的个数，只要 $|num-now|<r-l+1$ 就一定满足区间中存在 $0$ 也存在 $1$ 。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint num,n;\nbool check(int l,int r){\n\tprintf(\"? \");\n\tfor(int i=1;i<=l-1;i++) putchar('0');\n\tfor(int i=l;i<=r;i++) putchar('1');\n\tfor(int i=r+1;i<=n;i++) putchar('0');\n\tputs(\"\");\n\tfflush(stdout);\n\tint now;\n\tscanf(\"%d\",&now);\n\treturn abs(num-now)<(r-l+1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tprintf(\"? \");\n\tfor(int i=1;i<=n;i++) putchar('0');\n\tputs(\"\");\n\tfflush(stdout);\n\tscanf(\"%d\",&num);\n\tint l=1,r=n;\n\twhile(r-l>1){\n\t\tint mid=l+r>>1;\n\t\tif(check(l,mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"? \");\n    for(int i=1;i<=l;i++) putchar('0');\n    putchar('1');\n    for(int i=r+1;i<=n;i++) putchar('0');\n    puts(\"\");\n    fflush(stdout);\n    int f1;\n    scanf(\"%d\",&f1);\n    if(f1<num){\n    \tprintf(\"! %d %d\",l,r);\n\t}\n\telse printf(\"! %d %d\",r,l);\n    \n } \n```\n\n\n\n### E\n\n* 大致题意：定义多项式的欧几里得算法，$gcd(A(x),B(x))=gcd(B(x),A(x)\\%B(x))$ ，其中模操作指的是多项式除法中的余数，当 $A(x)\\%B(x)=0$ 时，操作结束，要求构造两个多项式 $A(x)$ 和 $B(x)$ ，满足正好可以让操作进行 $n$ 次，要求多项式各个系数的绝对值不超过 $1$。\n* 题解：考虑构造 $A(x)$ 为 $A(x)=B(x)*x+A(x)\\%B(x)$ ，设定最后的结果是 $A(x)=1,B(x)=0$ 然后按照辗转相除的规律反着做 $n$ 次，这样得到的 $A(x),B(x)$ 每次辗转相除都只会让最高项次数减一，所以能够保证操作次数能够倒着做 $n$ 次，这样处理出来的结果系数很可能是会超过 $1$ 的，但是最高项次数不会超过 $1$ 但是实际上，在找到符合条件的 $A(x),B(x)$ 后，可以在不改变多项式次数的情况下，直接对系数辗转相除，一步步将系数消除为符合条件的情况，系数的辗转相除实际上是对多项式线性组合，所以不会改变各多项式次数，即不改变原本的性质。实际上，操作上只需要把求出来的所有系数模 $2$ 即可。\n\n### F\n\n* 大致题意：不好描述，放链接：https://codeforces.com/problemset/problem/1194/E\n* 题解：n的范围为 $n\\leq 5000$ ，就是最多只能支持 $n^2\\log{n}$ 的复杂度，要套一个数据结构，首先将所有坐标变成正的，然后每个横过来的线段用一个以 $y$ 轴坐标作为标识的容器存，将每个竖过来的线段用一个以 $x$ 轴坐标作为标识的容器存，从上到下考虑每一个横过来的线段，首先枚举每个横线段，将所有与之相交的竖线段且最低点比该横线短坐标**小**的线段存进以最低点为表示的容器 $rb$ 中，用树状数组存该横坐标的贡献，然后枚举纵坐标比该线段大的线段，每次区间查询有多少竖线段与之相交即可。显然如果有 $x$ 个线段与之相交，对答案的贡献就是 $C_{res}^2$ ，每次枚举完一个纵坐标 $y$ ，就将 $rb[y]$ 中的数（即横坐标）在树状数组上删去它的贡献。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e4+13;\nvector<pair<int,int> > r[maxn],l[maxn];\nvector<int> cun[maxn]; \nstruct BIT{\n\tint a[maxn];\n\tvoid add(int x,int ad){\n\t\tfor(;x<=maxn-2;x+=x&(-x)) a[x]+=ad;\n\t}\n\tint query(int x){\n\t\tint ans=0;\n\t\tfor(;x;x-=x&(-x)) ans+=a[x];\n\t\treturn ans; \n\t}\n\tint get(int l,int r){\n\t\treturn query(r)-query(l-1); \n\t}\n\tvoid clear(){\n\t\tmemset(a,0,sizeof(a));\n\t}\n}bit;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint x1,y1,x2,y2;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tx1+=5001,y1+=5001,x2+=5001,y2+=5001;\n\t\tif(y1==y2) r[y1].push_back({min(x1,x2),max(x1,x2)});\n\t\telse l[x1].push_back({min(y1,y2),max(y1,y2)});\n\t}\n\tn=maxn-2;\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(auto p:r[i]){\n\t\t\tbit.clear();\n\t\t\tfor(int j=p.first;j<=p.second;j++){\n\t\t\t\tfor(auto v:l[j]){\n\t\t\t\tif(v.first<=i&&v.second>i){\n\t\t\t\t    cun[v.second].push_back(j);\n\t\t\t\t    bit.add(j,1);\n\t\t\t\t}\n\t\t\t  }   \n\t\t\t}\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tfor(auto p2:r[j]){\n\t\t\t\t\tint res=bit.get(p2.first,p2.second);\n\t\t\t\t\tans+=1ll*res*(res-1)/2;\n\t\t\t\t}\n\t\t\t\tfor(auto p2:cun[j]){\n\t\t\t\t\tbit.add(p2,-1);\n\t\t\t\t}\n\t\t\t\tcun[j].clear();\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n} \n```\n\n### G\n\n* 大致题意：给出 $n$ 个数，问这 $n$ 个数组成的集合的所有非空子集的和组成的数列的中位数。\n* 题解：对于每个集合都会存在一个补集与之对应，而两个集合的和的和一定是原 $n$ 个数的和，假设原 $n$ 个数的和为 $sum$ ，所以一定是一个大于等于 $sum/2$ ，一个小于等于 $sum/2$ ，基于这个性质，直到中位数一定是离 $sum/2$ 最近的数，现在少了一个 $0$ ，那么中位数一定是大于等于 $sum/2$ 的，所以实际上处理出所有的可能和然后从 $sum/2$ 枚举就可，处理所有可能的和可以用 $bitset$ 优化，复杂度为 $O(\\frac{n^2}{32})$ 。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbitset<5000000> dp;\nint main(){\n\tint x;\n\tint sum=0;\n\tint n;\n    scanf(\"%d\",&n);\n    dp[0]=1;\n    for(int i=1;i<=n;i++){\n    \tscanf(\"%d\",&x);\n    \tsum=sum+x;\n    \tdp=dp|dp<<x;//bitset快速处理子集和的种类 \n\t}\n\tint mid=sum+1>>1;\n\twhile(!dp[mid]) mid++;\n\tprintf(\"%d\",mid);\n} \n```\n\n","tags":["2021寒假训练"],"categories":["算法","刷题"]},{"title":"2021寒假训练2","url":"/2021/02/24/2021寒假训练2/","content":"\n## 2021寒假训练2\n\n<!-- more -->\n\n### C\n\n* 大致题意：有一个长度大于等于 $3$ 的字符串，规定字符串中没有两个连续的字符是相同的，$A,B$ 作博弈，每次从字符串中取出一个字符，要求取出这个字符之后的串也不能出现两个相邻的字符相同，且不能取两端的字符，最后无法进行任何操作的人获胜，问赢得是现手还是后手。\n* 题解：如果两端的字符相同，那么最后一定会达到两端相同的字符夹着一个不同的字符的情况，所以只要判断到达这种情况的是谁，即判断奇偶性即可，如果两端的字符不同，那么最后一定达到只剩下两个不同字符的情况，这样还是只要判断奇偶性，综上，分上述两类判断奇偶即可。\n\n### D\n\n* 大致题意：有 $n$ 项工作，每个工作有两个参数，工作时间和有趣度，现在问一些人想做什么工作，每问一次需要花费一个单位的时间，那个人可以选择做这个工作或者接受下一个询问（或者接受另一个工作），询问呈二叉树结构排布，现在需要构造一个询问二叉树，要求询问加做工作的时间最长不超过 $T$ ，问树上的工作的总有趣度最高能达到多少？\n* 题解：这题理解题意就要大半天……大体上是构造一个二叉树，给叶结点赋一些权值，要求叶节点的权值加深度的总和不超过 $T$ ，考虑从下网上合并，贪心的想，对于时间花费相同的任务，一定是可以放在同一个深度的，而且所有时间相同的节点一定是都要选的，而且结构是二叉树，如果将两个时间花费为 $t$ 的节点合并到一个父节点上，就可以将父节点看作时间花费为 $t+1$ 的节点，而且子节点权值越大越好，所以直接遍历时间，用一个优先队列维护同一个时间花费的工作，然后从小往上合并，对于最后合并出来的时间花费为$T$ 的节点集合，权值最大的即为答案。\n\n### E\n\n* 大致题意：有 $n$ 天，每天股票都有一个价格，在一天当中，你可以选择买入或者卖出赚差价，或者啥也不干，问最多可以赚多少钱。\n* 题解：这是一个可撤销贪心的好例子，贪心的想，如果现在我手上有 $m$ 张股票，在新的一天，我一定是选择手里股票面值最小的那个做差价最优，所以考虑用优先队列来维护这个过程，但是可能之后有更大的股价能让我赚更多的钱，怎么办，所以考虑每次更新的时候对新加入队列的值**复制**一份，将这个更新过程看作更新原先买入的股票的股价，如果之后这个新值成为队列中最小被更大的更新了，那么原先复制的一份可以看作在这时并不是做差价卖出了，而是新买入了一份股票。所以这样的处理达到了可翻回的贪心的效果，值得学习。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3e5+13;\nll ans;\nint a[maxn];\npriority_queue<int,vector<int>,greater<int> > q; \nint main()\n{\n\tint top=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!q.empty()){\n\t\t\tint now=q.top();\n\t\t\tif(a[i]>now){\n\t\t\t\tans+=1ll*(a[i]-now);\n\t\t\t\tq.pop();\n\t\t\t\tq.push(a[i]);\n\t\t\t\tq.push(a[i]);\n\t\t\t}\n\t\t\telse q.push(a[i]);\n\t\t}\n\t\telse q.push(a[i]);\n\t}\n\tprintf(\"%lld\",ans);\n}\n```\n\n### G\n\n* 大致题意：定义 $f(n)$ 为将 $n$ 十进制数位排序后重组得到的数，如 $f(30594)=3459$ ，求 $\\sum_{i=1}^nf(i)$，对结果模 $1e9+7$ （$n\\leq10^{700}$)。\n\n* 题解：数位 $dp$ 神仙题，考虑这样一件事情，对于一个数字 $30594$ 中对答案的贡献是 $3459$ ，不难发现\n  $$\n  3459 = 1111+1111+111+111+1+1+1+1+1\n  $$\n  将数字按升序排列后就会可以被形如 $111……1$ 的数的和表达，所以对于总和实际上只需要计算上面这种数的出现次数即可，还有一个规律，$30594$ 的十进制数位中，\n\n  * 比 $1$ 大的数有 $4$ 个，所以加了 $1111$\n\n  * 比 $2$ 大的数也有 $4$ 个，所以加了 $1111$\n\n  * 比 $3$ 大的数有 $4$ 个，所以加了 $1111$\n\n  * 比 $4$ 大的数有 $3$ 个，所以加了 $111$\n\n    ……\n\n  * 比 $9$ 大的数有 $1$ 个，所以加了 $1$\n\n  将上面算出来的数加起来就是答案，所以实际上，只要算出所有数的数位中，比一个数的大数位的有几个，就能算出贡献，考虑数位 $dp$ ，令 $dp[i][j][k][l]$ 表示前 $i$ 位中，大于等于 $k$ 的数位有 $j$ 个，是否卡上位，的总情况数，显然有，对于枚举到新的一位为数 $p$ ($1\\leq p\\leq9$)\n  $$\n  dp[i][j+(p>=k)][k][l|(p<a[i])]=\\sum dp[i-1][j][k][l]\n  $$\n  之后对于每一个数，枚举 $j$ 累计答案即可。时间复杂度和空间复杂度都是 $O(len^2*100)$\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  const int mod=1e9+7;\n  const int maxn=713;\n  int dp[maxn][maxn][10][2];//前i个中满足大于等于k的位恰好有j个而且是否是正好卡第i位的上界 \n  char s[maxn];\n  int a[maxn];\n  void add(int &a,int b){\n  \ta=1ll*(a+b)%mod;\n  }\n  int main()\n  {\n  \tscanf(\"%s\",s+1);\n  \tint n=strlen(s+1);\n  \tfor(int i=1;i<=n;i++) a[i]=s[i]-'0';\n  \tfor(int i=1;i<=9;i++) dp[0][0][i][0]=1;\n  \tfor(int i=1;i<=n;i++){\n  \t\tfor(int j=0;j<=i;j++){\n  \t\t\tfor(int k=1;k<=9;k++){\n  \t\t\t\tfor(int l=0;l<2;l++){\n  \t\t\t\t\tfor(int p=0;p<=(l?9:a[i]);p++){\n  \t\t\t\t\t\tadd(dp[i][j+(p>=k)][k][l|(p<a[i])],dp[i-1][j][k][l]);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} \n  \t\t}\n  \t} \n  \tint ans=0;\n  \tfor(int i=1;i<=9;i++){\n  \t\tint st=1;\n  \t\tfor(int j=1;j<=n;j++){\n  \t\t\tans=ans+1ll*(dp[n][j][i][0]+dp[n][j][i][1])*st%mod;\n  \t\t\tst=(1ll*st*10%mod+1)%mod;\n  \t\t\tans%=mod; \n  \t\t}\n  \t}\n  \tprintf(\"%d\",ans);\n   } \n  ```\n\n  \n\n  ","tags":["2021寒假训练"],"categories":["算法","刷题"]},{"title":"ABC191","url":"/2021/02/14/ABC191/","content":"\n## AtCoder Beginner Contest 190\n\n<!--more-->\n\n### C\n\n* 大致题意：给出一个 $h*w$ 的矩形字符画，矩形字符画由 \".\" 和 \"#\" 组成，现在问由 \"#\" 组成的图形是几边形。\n* 题解：扫一遍所有的位置，对于每个位置查询它周围（$a_{ij},a_{i,j+1},a_{i+1,j},a_{i+1,j+1}$）有多少个\"#\"，如果有奇数个，答案加一。其实可以这么，理解，符合答案的点一定可以把每一个边角（也就是产生边的数量的边角）覆盖到，所以这样的算法一定是对的。这个做法真的惊到我了，但是好像就是对的，纯属脑经急转弯……\n\n### D\n\n* 大致题意：给定圆心，直径，求圆包含了多少整点。\n* 题解：这题给爷整🤮啦，一看就是卡精度的题，但是这题卡的特别过分……，因为计算整点个数，为了方便在边上的点被算进去，可以适当增大半径的值，然后枚举横坐标即可，然后我从$1e-6$ 试到 $1e-14$ 才发现 $1e-14$ 是对的……，简直离谱。\n\n### E\n\n* 大致题意：给出一个图，存在自环，问从任何一个点出发，是否存在一条长度不为 $0$ 的路径回去，如果存在找出最短路径。\n* 题解：对每个点都跑一遍 $dijsktra$ 即可，只要对于起点出队的时候特判一下，如果起点第一次出队则不标记，否则标记并返回最短路即可。\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2500;\nstruct node{\n\tint x,dis;\n};\nbool operator <(node a,node b){\n\treturn a.dis>b.dis;\n}\nint n,vis[maxn];\nint ans[maxn],dis[maxn];\nvector<pair<int,int> > p[maxn];\npriority_queue<node> q;\nint dij(int x){\n\twhile(!q.empty()) q.pop();\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tq.push(node{x,0});\n\tint yes=0;\n\twhile(!q.empty()){\n\t\tnode now=q.top();\n\t\tq.pop();\n\t\tif(vis[now.x]) continue;\n\t\tif(now.x==x){\n\t\t\tif(!yes) yes=1;\n\t\t\telse return now.dis;\n\t\t}\n\t\telse vis[now.x]=1;\n\t\tfor(int i=0;i<p[now.x].size();i++){\n\t\t\tint v=p[now.x][i].se,w=p[now.x][i].fi;\n\t\t\tif(vis[v]) continue;\n\t\t\tif(now.dis+w<dis[v]){\n\t\t\t\tdis[v]=now.dis+w;\n\t\t\t\tq.push((node){v,dis[v]});\n\t\t\t} \n\t\t}\n\t} \n    return 0;\n}\nint main() \n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tp[u].push_back({w,v});\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tans[i]=dij(i);\n\t\tif(!ans[i]) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans[i]); \n\t}\n}\n```\n\n### F\n\n* 大致题意：有 $n$ 个数，每次操作可以挑出两个数 $x,y$，做一次 $gcd$ 或者做一次 $min$ ，之后把新产生的数加入当中，问最后剩余的数一共有多少种情况。\n* 题解：不管是 $gcd$ 还是 $min$ 操作，产生的两个数都是比原来的两个数小的，所以最后可能的数一定是比原本所有数小的，而且一定是原数列中某些数的因子，所以可以 $n\\sqrt{n}$ 枚举每个可能的因子，对于每个因子，计算出原数列中所有它的倍数的 $gcd$ ，如果 $gcd$ 的值大，说明这个数无论如何 $gcd$ 都无法得到，如果因子的值比最小值都要大，那么最后这个数也一定无法得到，所以一个因子 $x$ 成立的条件是 $gcd==x\\&x\\leq min$，对于处理出来的每个因子按照如上方法枚举统计答案即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=4000;\nmap<int,int> mp;\nvector<int> rb;\nint a[maxn];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j*j<=a[i];j++){\n\t\t\tif(a[i]%j==0){\n\t\t\t\tif(!mp[j]) mp[j]=a[i],rb.push_back(j);\n\t\t\t\telse mp[j]=__gcd(mp[j],a[i]);\n\t\t\t\tint t=a[i]/j;\n\t\t\t\tif(!mp[t]) \n\t\t\t\t{\n\t\t\t\t    if(t!=j) mp[t]=a[i],rb.push_back(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t!=j) mp[t]=__gcd(mp[t],a[i]);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\tint mn=1e9,ans=0;\n\tfor(int i=1;i<=n;i++) mn=min(mn,a[i]);\n\tfor(int i=0;i<rb.size();i++){\n\t\tif(mp[rb[i]]==rb[i]&&mp[rb[i]]<=mn) ans++;\n\t}c++\n\tprintf(\"%d\",ans);\n } \n```\n\n","tags":["atcoder"],"categories":["算法","刷题"]},{"title":"做题记录2.10","url":"/2021/02/11/做题记录2-10/","content":"\n> 因为太菜而被迫除夕营业的卑微大学生……\n\n## Codeforces Round #700 (Div. 2)\n\n<!-- more -->\n\n### B\n\n* 大致题意：一个主角打 $n$ 个怪，主角的生命值和攻击力分别是 $B,A$ ，第 $i$ 只怪的生命值和攻击值是 $b_i,a_i$ ,在攻击完一个怪后，怪的生命值变成 $b_i-A$ ，主角的生命值变成 $B-a_i$ ，规定怪和人的生命值一旦小于等于 $0$ 就会死亡，现在问主角能不能杀掉所有怪？(即使杀掉所有怪之后助教已死亡)。\n* 题解：对于任何一个怪物来说，杀掉它要付出的代价是固定的，可以先把这个值算出来，题目并没有要求杀掉所有怪以后主角还活着，所以其实只要能过够把怪物打到只剩下最后一击后还活着，所以只要生命值大于总代价减去一个怪物的攻击力即可。贪心的想，只要选择攻击力最大（设为 $x$ ）的那个最后一个打就能尽量保证代价小，所以比较一下 $sum-x$ 和 $B$ 即可。\n\n### C\n\n* 大致题意：交互题，有一个序列，要从序列中找一个数 $a_i$，满足 $a_{i-1}<a_i<a_{i+1}$，每次可以询问一个位置的数的值，第一个之前和最后一个之后默认为无穷大，要求询问次数在$100$ 次内。\n* 题解：不难看出最容易成立的位置的数为第一个数和最后一个数，所以可以先询问第一个数和最后一个数以及其周边的数的状况，如国两个之间有数成立直接输出那个位置即可，否则，可以断定第一个地方的数的趋势形成了一个单调降坡度，最后一个地方的数形成了一个单调增坡度，而满足 $a_{i-1}<a_i<a_{i+1}$ 的数一定存在于前面两个图形之间，所以可以直接二分，每次判断中间的点是否满足情况，始终保持左边单调减，右边单调增即可。由于这是一个排列，这样的点是一定存在的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+13;\nll a[maxn],b[maxn];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==1){\n\t\treturn printf(\"! 1\"),0;\n\t}\n\tint l=1,r=n,a,b;\n\tprintf(\"? 1\\n\");\n\tfflush(stdout);\n\tscanf(\"%d\",&a);\n\tprintf(\"? 2\\n\");\n\tfflush(stdout);\n\tscanf(\"%d\",&b);\n\tif(a<b) return printf(\"! 1\"),0;\n\tprintf(\"? %d\\n\",n);\n\tfflush(stdout);\n\tscanf(\"%d\",&a);\n\tprintf(\"? %d\\n\",n-1);\n\tfflush(stdout);\n\tscanf(\"%d\",&b);\n\tif(a<b) return printf(\"! %d\",n),0;\n\tint ans=0;\n\twhile(1){\n\t int now;\n\t int mid=l+r>>1;\n\t printf(\"? %d\\n\",mid);\n\t fflush(stdout);\n\t scanf(\"%d\",&now);\n\t printf(\"? %d\\n\",mid-1);\n\t fflush(stdout);\n\t scanf(\"%d\",&a);\n\t printf(\"? %d\\n\",mid+1);\n\t fflush(stdout);\n\t scanf(\"%d\",&b);\n\t if(now<a&&now<b){\n\t \tans=mid;\n\t\tbreak;\n\t }\n\t if(a<now&&now<b) r=mid;\n\t else l=mid;\n\t} \n\tprintf(\"! %d\",ans);\n } \n```\n\n### D1\n\n> 这两个贪心太恶心了，呜呜呜……\n\n* 大致题意：给出一个序列 $a$，定义 $seg(a)$ 为将序列 $a$ 种相邻的相同的数合并成一个后，序列中数的数量，现在给 $a$ 中数染色，染成 $1$ 或者 $0$ ，染色之后将染成 $1$ 的数和染成 $0$ 的数分开来，形成两个序列 $a^1$ 和 $a^2$ ，现在寻找一种染色方式使得 $seg(a^1)+seg(a^2)$ 结果最大。\n* 题解：贪心的考虑，假设现在有两个队列，开头分别为 $x$ 和 $y$ ，现在要将 $a_i$ 插入，若是 $a_i$ 和其中的一个相同，一个不同，那么最优情况一定是将 $a_i$ 放在不同的队列里，答案加一，如果 $a_i$ 和 $x$，$y$ 都不相同，那么插在哪都会使得答案加一，可以再多考虑一步，考虑 $a_{i+1}$，如果 $a_{i+1}$ 已经和 $x$ 相同，那么假如把 $a_i$ 插在 $x$ 前，可以使得下一步的答案多一种选择，否则就插在 $y$ 前，因为假如 $a_{i+1}$ 与 $y$ 相同，$a_i$插在 $y$ 前，如果都不相同，插在哪里就不会对答案产生影响。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nint a[maxn];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    int x=0,y=0,ans=0;\n    for(int i=1;i<=n;i++){\n    \tif(x!=a[i]&&y!=a[i]){\n    \t\tif(a[i+1]==x) x=a[i];\n\t\t\telse y=a[i];\n\t\t\tans++; \n\t\t}\n\t\telse if(x!=a[i]) x=a[i],ans++;\n\t\telse if(y!=a[i]) y=a[i],ans++;\n\t}\n\tprintf(\"%d\",ans); \n } \n```\n\n\n\n### D2\n\n* 大致题意：把上一题的找最大改成找最小。\n* 题解：贪心的考虑，如果要不一样的数目最小，那么原串中相邻一样的串一定是一起移动的，所以可以先对原串相邻一样的数进行去重，之后，也是考虑刚才的模型，两个队列的末尾数分别为 $x$ 和 $y$ ，现在要将 $a_i$ 插入，如果 $a_i$ 在之前出现过，有一种选择是将前一个$a_i$ 之前的数全部搬走，将现在的 $a_i$ 插进去，这样可以使得答案减一，但是条件是夹在中间的数可以被删去，所以每出现一次数对该数进行标记，答案加一，一但遇到已经标记过的数，就将标记全清空，重新标记现在的两个队列末尾的数，答案不加一。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nint a[maxn];\nmap<int,int> mp;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tint ans=0,m=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]!=a[i-1]) a[++m]=a[i];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!mp[a[i]]){\n\t\t\tmp[a[i]]=1;\n\t\t\tans++;\n\t\t}\n\t\telse{\n\t\t\tmp.clear();\n\t\t\tmp[a[i]]=1;\n\t\t\tmp[a[i-1]]=1;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n}\n```\n\n### E\n\n* 大致题意：构造一个边带权有向图，使得图上从点 $1$ 到点 $n$ 的路径在 $[l,r]$ 上均匀分布（指每个长度的路径只有一条，且只存在这 $r-l+1$ 条路径），给定 $l,r$，从 $n$ 的大小，边的数量，到每条边的边权都需要构造。（$n\\leq32$）\n\n* 题解：神仙构造，不过这个 $n$ 的数据范围已经很明显的暗示需要利用二进制的性质，按照如下方法构图即可，$n$ 设置为 $23$，从点 $1$ 向点 $2-23$ 都连一条长度为 $l$ 的有向路径，之后从 点$i$ （$2\\leq i\\leq22$）向满足 $j>i\\&j\\neq23$ 的店连一条长度为 $2^{i-2}$ 的有向路径，现在可以知道，从点 $1$ 到达点 $i$ 的路径长度范围是 $[l,l+2^{i-2}-1]$，剩下的可以参考树状数组的做法，如果 $r-l$ 的第 $i$ 位为 $1$ ，那么求出将比 $i$ 小的所有位（包括 $i$ ）变成 $0$ 之后的数的值 $t$ ，再从 $i+2$ 连一条长度为 $t+1$ 的边向 $n$ 即可。可以知道对于每个这样的边，构造了 $[l+t+1,l+2^{i-2}+t]$ 的范围的路径，及树状数组的套路区间。\n\n### F（div1D)\n\n* 大致题意：存在一个树，每个树点都有一个权值 $v_i$ ，多次询问，每次询问给出四个值 $u,v,l,r$ 询问点 $u$ 和点 $v$ 的路径上是否存在一个权值 $c_i$ 满足 $l\\leq c_i\\leq r$ ，且 $c_i$ 在这条路径上的点的出现次数为奇数。\n* 题解：和书上路径的出现次数相关，明显是树上莫队，但是这题的对于权值的范围的限制不太好处理，所以考虑在莫队的删除增加或者查询时再加一个数据结构，对于每个询问，莫队的修改是 $O(\\sqrt{n})$ 的而查询是 $O(1)$ 的，所以如果用全 $log$ 数据结构会产生 $q\\sqrt{n}logn$ 的复杂度，好像是会超时，所以需要一个修改 $O(1)$ 的数据结构，所以考虑莫队的修改的时候，再对权值分块处理。但是这题时间貌似卡的非常紧，所以需要把莫队的修改删除函数直接合并，因为对这题来说修改删除对总体产生的影响是完全一样的……\n\n```c++\n#include <bits/stdc++.h>\n#pragma GCC optimize (2)\nusing namespace std;\nconst int maxn=6e5+13; \nint bel[maxn];\nvector<int> eg[maxn]; \nstruct Q{\n\tint l,r,f,num,ql,qr;\n}tt[maxn];\nint fir[maxn],las[maxn],cnt[maxn];\nint fa[maxn][30],lg[maxn+5];\nint dep[maxn],ans[maxn];\nint p[maxn],a[maxn],vis[maxn];\nint tot,sz2;//sz2是第二次分块每个块的大小 \nint b[maxn],bl[maxn];//b表示每一个块内符合情况数的个数,每一个块的奇偶性 \nvoid pre()\n{\n\tfor(int i=1;i<=300013;i++) lg[i]=lg[i>>1]+1; \n}\nvoid dfs(int x,int f) \n{\n\tp[fir[x]=++tot]=x;\n\tfa[x][0]=f,dep[x]=dep[f]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\t}\n\tfor(int i=0;i<eg[x].size();i++)\n\t{\n\t\tint v=eg[x][i];\n\t\tif(v!=f) dfs(v,x);\n\t}\n\tp[las[x]=++tot]=x;\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\twhile(dep[x]>dep[y])\n\t{\n\t\tx=fa[x][lg[dep[x]-dep[y]]];\n\t}\n\tif(x==y) return y;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i],y=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nbool cmp(Q a,Q b)\n{\n\treturn bel[a.l]==bel[b.l]?(bel[a.l]&1?a.r<b.r:a.r>b.r):bel[a.l]<bel[b.l]; \n }\nint query(int l,int r){\n\tif(bl[l]==bl[r]){\n\t\tfor(int i=l;i<=r;i++){\n\t\t\tif(cnt[i]&1) return i;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=l;i<=bl[l]*sz2;i++){\n\t\t\tif(cnt[i]&1) return i; \n\t\t}\n\t\tfor(int i=(bl[r]-1)*sz2+1;i<=r;i++){\n\t\t\tif(cnt[i]&1) return i;\n\t\t}\n\t\tfor(int i=bl[l]+1;i<=bl[r]-1;i++){\n\t\t\tif(b[i]){\n\t\t\t\tfor(int j=sz2*(i-1)+1;j<=sz2*i;j++){\n\t\t\t\t\tif(cnt[j]&1) return j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nvoid work(int t){\n\tint x=a[t];\n\tif(cnt[x]&1) b[bl[x]]--;\n    cnt[x]^=1;\n    if(cnt[x]&1) b[bl[x]]++;\n}\nint main()\n{\n\tlg[0]=-1;\n\tpre();\n    int n,m,u,v,l,r;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\teg[v].push_back(u);\n\t\teg[u].push_back(v);\n\t\t}\n    dfs(1,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&u,&v,&l,&r);\n\t\tif(fir[u]>fir[v]) swap(u,v);\n\t\tint f1=lca(u,v);\n\t\tif(f1==u||f1==v)\n\t\t{\n\t\t\ttt[i]=(Q){fir[u],fir[v],0,i,l,r};\n\t\t } \n\t\telse{\n\t\t\ttt[i]=(Q){las[u],fir[v],f1,i,l,r};\n\t\t}\n\t\t}\n\tl=1,r=0;\n\tint num=(int)sqrt(2*n);\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t bel[i]=i/num+1;\n\t}\n\tsort(tt+1,tt+1+m,cmp);\n\tsz2=(int)sqrt(1.0*n);\n\tfor(int i=1;i<=n;i++){\n\t\tbl[i]=(i-1)/sz2+1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\twhile(l>tt[i].l) work(p[--l]);\n\t\twhile(r<tt[i].r) work(p[++r]);\n\t\twhile(l<tt[i].l) work(p[l++]);\n\t\twhile(r>tt[i].r) work(p[r--]);\n\t\tif(tt[i].f) work(tt[i].f); \n\t\tans[tt[i].num]=query(tt[i].ql,tt[i].qr);\n\t\tif(tt[i].f) work(tt[i].f);\n\t }c++\n\t for(int i=1;i<=m;i++) printf(\"%d\\n\",ans[i]);\t\n}\n```\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"2021寒假训练1","url":"/2021/02/08/2021寒假训练1/","content":"\n## 2021寒假训练1\n\n<!-- more -->\n\n### C\t\n\n* 大致题意：有一块大小为 $H*W$ 的方格矩形，现在要从坐标 $(C_h,C_w)$ 处前往 $(D_h,D_w)$ 处，规定每次可以走到附近相连的一格，或者使用依次魔法，随即转移到 $5*5$ 区间内的任意一格子，问最少需要多少次魔法才能到达终点？\n* 题解：从每个点向周边 $5*5$ 的矩形范围内的点连一条权值 $1$ 边，向临近的点连一道权值为 $0$ 的边，之后 dijsktra 跑最短路即可。\n\n### D\n\n* 大致题意：给出一个有向图，再给出一些边，这些边的方向有些是知道的，有些方向是不知道的，现在需要给这个图没有方向的边定一个方向，使得这个图成为有向无环图，问如何定。\n* 题解：成为有向无环图的意思也就是可以进行拓扑排序，拓扑排序有这样一个性质，对于一个已经完成拓扑排序的一张图，如果连一条有向边从先出队列的点到后出队列的点连一条有向边，那么这张图也是有向无环图。按照这个性质，可以先拿出所有的有向边进行拓扑排序，如果对于已经有的有向边成图就出现了环，由于不能改变已经有的有向边，所以一定是不成立的，如果有向边成图可以拓扑排序，利用上面的性质，按照点的拓扑序对于每个无向边定方向，拓扑序小的向拓扑序大的连边即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+13;\nvector<int> p1[maxn];\nvector<int> p2[maxn]; \nint to[maxn];\nint mp[maxn];\nstruct node{\n\tint tp,u,v;\n}tt[maxn];\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tint cnt=0;\n\t\tqueue<int> q;\n\t\tint n,m,tp,u,v;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++) p1[i].clear(),p2[i].clear(),mp[i]=0,to[i]=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&tp,&u,&v);\n\t\t\ttt[i]=(node){tp,u,v};\n\t\t\tif(tp)\n\t\t\t{\n\t\t\t\tp1[u].push_back(v);\n\t\t\t\tto[v]++;\n\t\t\t}\n\t\t\telse p2[u].push_back(v),p2[v].push_back(u);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(to[i]==0) q.push(i);\n\t\t}\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint now=q.front();\n\t\t\tq.pop();\n\t\t\tmp[now]=++cnt;\n\t\t\tfor(int i=0;i<p1[now].size();i++)\n\t\t\t{\n\t\t\t\tint v=p1[now][i];\n\t\t\t\tto[v]--;\n\t\t\t\tif(to[v]==0)\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt<n)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"Yes\\n\");\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(tt[i].tp) printf(\"%d %d\\n\",tt[i].u,tt[i].v);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(mp[tt[i].u]>mp[tt[i].v]) swap(tt[i].u,tt[i].v);\n\t\t\t\tprintf(\"%d %d\\n\",tt[i].u,tt[i].v);\n\t\t\t}\n\t\t}\n\t}\n } \n```\n\n### E\n\n* 大致题意：给出一个 $n$ 阶图，一共有 $m$ 条边，每个点都有个权值 $v_i$ 保证 $v_i$ 的奇偶性与点的度相同，现在需要给每条边定一个权值 $w_i$ 规定 （$-2n^2\\leq w_i\\leq 2n^2$），使得与每个点相连的边的权值总和等于点的权值。\n* 题解：这个题为类似的构造题提供了一个很好的思路。对于一个图而言，要确定一条边的权值并不容易，**所以不妨先拿出一棵树来看**，在一棵树上，权值很好定，因为对于与叶节点相连的边来说，该边权值只能等于叶节点的权值，然后往上递推，每次用父节点权值减去子节点，就可以得到所有边的权值，所以假如选出来的边组成的树在完成如上操作后已经可以满足要求，那么其他点全部为 $0$ 即可。但是可能会存在一种情况，就是往上递推到根节点时，根节点值不为 $0$ ，这时考虑给其他的边赋值，按照上述的递推规则，会发现，假如边连接的两个点深度奇偶性相同那么他会对最后的节点的值产生贡献，而且这条边连接的两个点对根节点产生贡献是相同的，所以贡献是两倍的。如果根节点剩余权值是奇数，那么无论怎么改都是不成立的。如果是偶数，在给树点奇偶染色后，任意选择两个同颜色的点，判断这条边的变化对根节点产生的是正贡献还是负贡献，然后填补具体的值即可。\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2e5+13; \nvector<pair<int,int> > p[maxn];\nll ans[maxn],w[maxn];\nint col[maxn],fa[maxn],dp[maxn];\nint a[maxn],b[maxn];\nbool vis[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nvoid dfs1(int rt,int fa){//黑白染色用于在树上判断奇偶性 \n\tcol[rt]=col[fa]^1;\n\tdp[rt]=dp[fa]+1;\n\tfor(int i=0;i<p[rt].size();i++){\n\t\tint v=p[rt][i].second;\n\t\tif(v==fa) continue;\n\t\tdfs1(v,rt);\n\t}\n}\nvoid dfs2(int rt,int fa){//求答案 \n\tfor(int i=0;i<p[rt].size();i++){\n\t\tint v=p[rt][i].second,id=p[rt][i].first;\n\t\tif(v==fa) continue;\n\t\tdfs2(v,rt);\n\t\tans[id]+=w[v];\n\t\tw[rt]-=w[v];\n\t\tw[v]=0;\n\t}\n} \nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&w[i]);\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tint f1=find(a[i]),f2=find(b[i]);\n\t\tif(f1==f2) continue;\n\t\tfa[f1]=f2;\n\t\tp[a[i]].push_back({i,b[i]});\n\t\tp[b[i]].push_back({i,a[i]});\n\t\tvis[i]=1;\n\t}\n\tdfs1(1,0);\n\tdfs2(1,0);\n\tif(w[1]==0){\n\t\tprintf(\"YES\\n\");\n\t\tfor(int i=1;i<=m;i++) printf(\"%lld\\n\",ans[i]);\n\t\treturn 0;\n\t}\n\telse if(abs(w[1])&1){\n\t\treturn printf(\"NO\\n\"),0;\n\t}\n\tint yes=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(vis[i]||col[a[i]]!=col[b[i]]) continue;\n\t\tprintf(\"YES\\n\");\n\t\tif(dp[a[i]]&1){\n\t\t\tans[i]=w[1]/2;\n\t\t\tw[a[i]]-=ans[i];\n\t\t\tw[b[i]]-=ans[i];\n\t\t}\n\t\telse{\n\t\t\tans[i]=-w[1]/2;\n\t\t\tw[a[i]]-=ans[i];\n\t\t\tw[b[i]]-=ans[i];\n\t\t}\n\t\tyes=1;\n\t\tdfs2(1,0);\n\t\tbreak;\n\t}\n\tif(!yes) printf(\"NO\");\n\telse{\n\t\tfor(int i=1;i<=m;i++) printf(\"%lld\\n\",ans[i]);\n\t}  \n } \n```\n\n### F\n\n* 大致题意：给定 $n$ 个数，要求支持一下两个操作，区间修改操作 $[l,r]$ 全部加 $x$ ，区间查询操作输出 $\\sum_{i=l}^rf(a_i)$ ,$f(i)$ 表示斐波那契数列第 $i$ 个数。\n\n* 题解：思路很简单，众所周知矩阵运算有结合律，所以区间修改，区间查用线段树维护，斐波那契数列的推进可以用矩阵来实现。\n  $$\n  \\begin{pmatrix}\n  0 & 1 \\\\\n  1 & 1 \\\\\n  \\end{pmatrix}\n  \\begin{pmatrix}\n  a_i\\\\\n  a_{i+1}\n  \\end{pmatrix}\n  =\n  \\begin{pmatrix}\n  a_{i+1}\\\\\n  a_{i+2}\n  \\end{pmatrix}\n  $$\n  对于线段树每个点，维护两个数和一个懒标记矩阵，一个是 $f(a_i)$ ，一个是 $f(a_{i+1})$ ，每次区间更新做矩阵乘法即可，查询就是线段树的求和查寻。\n\n### G\n\n* 大致题意：有 $n$ 座山，也有 $m$ 只小猫在山上玩，每只猫到达山的时间为 $t_i$ ，在第 $h_i$ 座山上等人来收，第 $i$ 座山和第 $i-1$ 座山相距 $d_i$ ， 现在从起点 $1$ ，陆陆续续派 $p$ 个人来收猫，每个人走路的速度都是 $1$ 秒一个单位，问最少要花多长时间才能收完所有猫？\n\n* 题解：人能收到猫，肯定是因为人到达的时间比猫到达的时间晚，可以先计算出每座山的具体距离位置，设第 $i$ 座山为$s_i$ ，要能够接出每只猫出发的最早时间，其实就是 $a_i=t_i-s_{h_i}$ ，然后按照这个排序，易知如果一个人出发时间大于 $a_i$ ,那他一定可以接到这只猫，这只猫的等待时间也就是出发时间 $T$ 减去最早出发时间 $a_i$ 。而且易知一定是把所有人都安排在一个恰好能接到一直猫的时间点出发是最优的，否则一定能够通过微调获得更优解，所以根据上面这些分析可以列出 $dp$ 方程，用 $dp[i][j]$ 表示 $i$ 个人过后已经接了 $j$ 只猫。\n\n  可以列出下面的 $dp$ 方程，正常 $dp$ 复杂度 $O(pm^2)$ ，显然过不去那么大数据，推一下式子发现可以斜率优化，这个我单独写一篇 $blog$ 讲，最后复杂度是 $O(pm)$\n\n$$\ndp[i][j]=\\min_{k=i-1}^{j-1}\\{dp[i-1][k]+\\sum_{t=k+1}^j(a_j-a_t)\\}\n$$","tags":["2021寒假训练"],"categories":["算法","刷题"]},{"title":"2021牛客寒假算法基础集训营3","url":"/2021/02/08/2021牛客寒假算法基础集训营3/","content":"\n## 2021牛客寒假算法基础集训营3\n\n>感觉这场最简单了，但是为啥打的这么垃圾呢，明明感觉一开始打的蛮舒服，为什么事情会变成这样呢，为什么……（白学家手动狗头）\n\n<!--more-->\n\n### A \n\n* 大致题意：已知有 $x\\equiv a \\bmod p$ , $y\\equiv b \\bmod p$ ,求 $\\gcd (x,y) \\bmod p$ 的最大值，起初$a,b,p$ 的值是给定的，对于计算出的最大值，构造出符合情况的 $x$，$y$ 。\n* 题解：既然是要让 $\\gcd(x,y)$ 最大，那么可能的最大值也就是 $p-1$ ，也就是 $p-1$ 是 $x$ 和 $y$ 的因子，而且满足 $x\\equiv a \\bmod p$ ，一种比较朴素的构造方法就是 $x=(p-1)*(p-a)$，$y=(p-1)*(p-b)$ ,但是这样构造可能会出现 $p-a$ 和 $p-b$ 不互素所以现在目标找出一个 $m$ 满足 $p-a+mp$ 和 $p-b$ 互素，令 $p-a=k_1,p-b=k_2$，假设 $k_2>k_1$ ，用求出 $n$ ,使得 $np\\equiv 1(\\bmod k2)$，构造 $m=(k_2-k_1+1)n$ ,易知 $k1+(k2-k1+1)np$ 与 $k1$ 互素（辗转相除就能证明）。故$x=(p-1)*k_1,y=(p-1)*(k_1+(k2-k1+1)np)$ 即满足题意，求逆元的时候用扩展欧几里得定理即可。（还需要特判一下 $a,b$ 都为 $0$ 的情况）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll x,y;\nvoid exgcd(int a,int b,ll &x,ll &y){\n\tif(!b) x=1,y=0;\n\telse exgcd(b,a%b,y,x),y=y-(a/b)*x;\n}\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint a,b,p;\n\t\tscanf(\"%d%d%d\",&a,&b,&p);\n\t\tif(a==0&&b==0){\n\t\t\tprintf(\"0 0 0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tll k1=p-a,k2=p-b;\n\t\tint yes=0;\n\t\tif(k1<k2) yes=1,swap(k1,k2);\n\t\texgcd(p,k1,x,y);\n\t\tx=(x+k1)%k1;\n\t\tll ans1=1ll*(p-1)*(k2+(1-k2+k1)*x*p),ans2=1ll*(p-1)*k1;\n\t\tif(yes) swap(ans1,ans2);\n\t\tprintf(\"%d %lld %lld\\n\",p-1,ans2,ans1);\n\t}\n}\n```\n\n### B\n\n* 大致题意：$n$ 位同学进行期末考试，每个同学都有五个等地预估分数线，分别为 $A,B,C,D,E$ 档对应的分数（分数值依次递降），学校规定获得 $A$ 档的人数不能超过 $k$ 个，问所有人最后得分的最大值和最小值可能的差的最小值是多少？\n* 题解：这题让我学到了一个新算法，尺取法，大概意思就是首先确定一段符合条件的区间，然后推进左端点，右端点根据题目的要求做推进，每次找到一段符合条件的区间就计算一次对答案的贡献，最后输出最优解。在这题上，首先可以按照这 $5n$ 个可能的成绩排序，然后设定初始左端点为 $l=1，r=1$ ，之后不断推进右端点，维护当前已经被包含在内的人数和 $A$ 等地数量，依此产生一个符合条件的解，当区间内出现一个人多等地的成绩时，优先不去选 $A$ 档的分数。之后每次推进 $l$ ，调整 $r$ ，计算答案的贡献即可，具体看代码。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=6e5+13;\nstruct node{\n\tint val,id,tag;\n};\nint a[maxn],vis[maxn];//是否已经出现过A等地\nint n,k,cala,cal; \nnode tt[maxn];\nbool operator <(node a,node b){\n\treturn a.val<b.val;\n}\nbool check(){\n\treturn (cal==n&&cala<=k);\n}\nvoid add(int x){\n\tif(vis[tt[x].id]==1&&a[tt[x].id]) cala--;//能不选a就不选\n\tvis[tt[x].id]++;\n\tif(vis[tt[x].id]==1) cal++;\n\tif(tt[x].tag) a[tt[x].id]=1;\n\tif(vis[tt[x].id]==1&&a[tt[x].id]) cala++;  \n}\nvoid del(int x){\n\t if(vis[tt[x].id]==1&&a[tt[x].id]) cala--;\n\t vis[tt[x].id]--;\n\t if(vis[tt[x].id]==0) cal--;\n\t if(tt[x].tag) a[tt[x].id]=0;\n\t if(vis[tt[x].id]==1&&a[tt[x].id]) cala++;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=5*n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ttt[i].id=(i-1)/5+1;\n\t\ttt[i].tag=(i%5==1);\n\t\ttt[i].val=x;\n\t}\n\tsort(tt+1,tt+1+5*n);\n\tint r=1,ans=1e9;\n\tfor(int i=1;i<=5*n;i++){\n\t\tif(i>1) del(i-1);\n\t\twhile(r<=5*n&&!check()) add(r++);\n\t\tif(check()) ans=min(ans,tt[r-1].val-tt[i].val);\n\t}\n\tprintf(\"%d\",ans);\n } \n```\n\n### C\n\n* 大致题意：平面上有 $n$ $(n\\leq10)$个敌人，每个敌人都可以看作一个半径为 $r_i$ 的圆，一个人可以攻击 $k$ ($k\\leq3$)次，每次攻击范围为一个半径为 $R$ 的圆，如果敌人所在的圆和这个圆相交或者相互包含，则这个敌人就会被消灭，问总共能消灭多少敌人。($|R|,|r_i|\\leq7$)\n* 题解：这题目的数据范围实在太良心辣，这题可以采取最暴力的方式遍历加 $dfs$ ，每次攻击都枚举圆心，然后进行 $dfs$ ，发现坐标范围十分小，所以直接枚举圆心坐标即可，为了防止超时，我在 $dfs$ 前对点进行了筛选，把和敌方圆没有交点的圆心坐标去掉了。\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nconst int maxn=20;\nint vis[maxn];\nvector<pair<int,int> > p;\nvector<int> rb[45];\nint get_dis(int x1,int y1,int x2,int y2){\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\nint x[maxn],y[maxn];\nint r[maxn];\nint ans=0;\nint n,k;\nint R;\nvoid dfs(int ci,int now){\n\tif(ci==k){\n\t\tans=max(now,ans);\n\t\treturn;\n\t}\n\tfor(int i=0;i<p.size();i++){\n\t\trb[ci].clear();\n\t\tint cx=p[i].fi,cy=p[i].se;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(vis[j]) continue;\n\t\t\tif(get_dis(cx,cy,x[j],y[j])<=(r[j]+R)*(r[j]+R)){\n\t\t\t\tvis[j]=1;\n\t\t\t\trb[ci].push_back(j);\n\t\t\t}\n\t\t}\n\t\tdfs(ci+1,now+rb[ci].size());\n\t\tfor(int j=0;j<rb[ci].size();j++) vis[rb[ci][j]]=0;\n\t}\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&k,&R);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d\",&x[i],&y[i],&r[i]);\n\t}\n\tfor(int i=-7;i<=7;i++){\n\t\tfor(int j=-7;j<=7;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int z=1;z<=n;z++){\n\t\t\t\tif(get_dis(i,j,x[z],y[z])<=(r[z]+R)*(r[z]+R)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt) p.push_back({i,j});\n\t\t}\n\t}\n\tdfs(0,0);\n\tprintf(\"%d\",ans);\n}\n```\n\n### D\n\n* 大致题意：输出比当前年份大而且数位和和当前年份相同的最小年份（$2021\\leq n\\leq 2030$）。\n* 题解：对于 $2021\\leq n\\leq 2029$ 得情况，直接将第三位加一，第四位减一即可，即输出 $n+9$ 对于 $n=2030$ 得情况，输出 $2102$ 即可。\n\n### E\n\n* 大致题意：有 $n$ 个数，$m$ 个操作，操作分两种方式，一种是把 $x$ 位置的数清空，一种是询问区间 $[l,r]$ 间为被清空的数是否存在一个数出现过两次及以上。数据范围 $1e5$\n* 题解：采用线段树进行维护，对于每个数维护当前这个数左边第一个和它相同的数的位置，然后放在线段树上查询区间最大值，修改时进行单点修改，每次询问是只要对 $[l,r]$ 区间进行查询，若结果大于等于 $l$ 则表示成立，否则不成立。为了方便修改还要再维护一下右边第一个和它相同的数的位置。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+13;\nint a[maxn],le[maxn],ri[maxn],lst[maxn];\nint sum[maxn<<2];\nvoid up(int x){\n\tsum[x]=max(sum[x<<1],sum[x<<1|1]);\n}\nvoid build(int x,int l,int r){\n\tif(l==r){\n\t\tsum[x]=le[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(x<<1,l,mid);\n\tbuild(x<<1|1,mid+1,r);\n\tup(x);\n}\nvoid modify(int x,int l,int r,int pos,int t)\n{\n\tif(l==r){\n\t\tsum[x]=t;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(pos<=mid) modify(x<<1,l,mid,pos,t);\n\telse modify(x<<1|1,mid+1,r,pos,t);\n\tup(x);\n}\nint query(int x,int l,int r,int ll,int rr){\n\tif(ll<=l&&r<=rr){\n\t\treturn sum[x];\n\t}\n\tint mid=l+r>>1;\n\tint ans=0;\n\tif(ll<=mid) ans=max(ans,query(x<<1,l,mid,ll,rr));\n\tif(rr>mid) ans=max(ans,query(x<<1|1,mid+1,r,ll,rr));\n\treturn ans;\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(lst[a[i]]) ri[lst[a[i]]]=i,le[i]=lst[a[i]];\n\t\tlst[a[i]]=i;\n\t}\n\tbuild(1,1,n);\n\twhile(m--){\n\t\tint op;\n\t\tscanf(\"%d\",&op);\n\t\tif(op==1){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tmodify(1,1,n,x,-1);\n\t\t\tif(le[x]) ri[le[x]]=ri[x];\n\t\t\tif(ri[x]) le[ri[x]]=le[x],modify(1,1,n,ri[x],le[x]);\n\t\t}\n\t\telse{\n\t\t\tint l,r;\n\t\t\tscanf(\"%d%d\",&l,&r);\n\t\t\tprintf(\"%d\\n\",query(1,1,n,l,r)>=l);\n\t\t}\n\t}\n} \n```\n\n### F\n\n* 大致题意：规定字符串匹配中符号 '#' 可以替代所有任何长度的字符串，先保证给出的所有字符串都包含至少一个 '#' ，问一共有多少字符串与给出的 $n$ 个字符串都相互匹配，如果有无数个就输出 $-1$ 。\n* 题解：盲猜答案不是 $0$，就是 $-1$ ，~~这不是显然~~，'#' 可以批配任意长度的字符串，那么对于所有串一定能找到一种匹配方式使他们全部相互匹配。可能产生问题的地方就是每个串第一个 '#' 之前的部分和最后一个 '#' 之后的部分，从所有串中找出最长的前缀和最长的后缀，用其他的串的前缀和后缀和最长的前缀后缀进行批配，在长度限制内，只要出现不一样一定不成立。\n\n### G\n\n* 大致题意：一共有 $n$ 个小朋友，$m$ 对朋友关系，原定第 $i$ 个小朋友会被分到 $a_i$ 个糖果，现在需要保证每个小朋友分到的糖果数不能比他的任何一个朋友少，问最后最少需要发多少个糖果。\n* 题解：并查集维护即可，保证每个连通块中糖果数取连通块中所有小朋友的最大值，最后累加答案。\n\n### H\n\n* 大致题意：规定将每个小写字母都映射成一个数字，按照 $x-'a'+1$ 的规则映射，然后将数字从左向右排布，如 $abcz$ 对应 $12326$。现在给出原串，问是否存在一个和该串不一样的字符串对应的数字序列与原串完全相同。\n* 题解：很朴素的想法是，如果有两个个位数，那么可以组合成为一个两位数，如两个 'b' ，可以合成一个 'v' 其实这个题有很大的坑，如果有一个两位数可以拆成两个一位数字符，把刚才的过程反过来即可。注意到如果数字串中出现了 $0$ ，那么就不能动这个字符，所以首先要判断字符串中是否有 $0$ ，再去判断是否能通过拆分或者合并改变字符串。\n\n### I\n\n* 大致题意：序列m的美观度表示所有整数 $i$ 满足 $S_i=S_{i+1}$ ,对于一个字符串 $S$ ，求它美观度最大的子串的美观度值，子串指的是删除原串部分字符后形成的串。\n* 题解：对于连续重复的字符串显然是不能删去的，而对于两段相同字符形成的字符串，中间可能会夹杂其他字符，这是可以选择删去中间的字符，让两端字符首位相接来让字符串变得更大，根据上述规则 $dp$ 即可，$dp[i]$ 表示到第 $i$ 个位置对应的答案，维护字符出现的上一个位置，再删去中间的数何不删去中间数的两种情况取个最大值即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e6+13;\nint a[maxn],lpos[maxn];\nint vis[maxn];\nint dp[maxn];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    int ans=0,j;\n    for(int i=1;i<=n;i++){\n        j=i;\n        int cnt=0;\n        while(a[j]==a[j+1]&&j<=n) j++,cnt++;\n        if(!vis[a[i]]){\n            dp[j]=dp[i-1]+cnt;\n        }\n        else{\n            dp[j]=max(dp[i-1]+cnt,dp[lpos[a[i]]]+1+cnt);\n        }\n        vis[a[i]]=1;\n        lpos[a[i]]=j;\n        i=j;\n    }\n    printf(\"%d\",dp[n]);\n }\n```\n\n### J\n\n* 大致题意：有 $n$ 个数，每个数上都有一个数字，$A$ 和 $B$ 玩游戏，规定 $A$ 先手，两个人每次轮到自己的时候可以选取一个运算符号（乘号或者加号），拿出两个数做运算然后将数放回去，如果最后留的那个数是奇数，那么 $A$ 赢，否则 $B$ 赢，问最后谁会赢。\n* 题解：博弈论，如果 $n$ 是奇数，那么最后一句由 $B$ 来做，无论最后剩下什么数，永远可以通过乘或者加组合出偶数，所以 $B$ 必定赢，若 $n$ 是偶数，如果这 $n$ 个数中偶数的数量大于等于 $2$ ，那么无论 $A$ 现手怎么处理，后手 $B$ 都能为自己留下两个偶数直到最后一局（两个偶数无论乘或者加都只能产生偶数），所以 $B$ 必胜，否则若偶数小于2个，A永远能为自己留下一个奇数，$A$ 必胜。\n\n","tags":["牛客"],"categories":["算法","刷题"]},{"title":"2021牛客寒假算法基础集训营2","url":"/2021/02/07/2021牛客寒假算法基础集训营2/","content":"\n## 2021牛客寒假算法基础集训营2\n\n<!-- more -->\n\n### A\n\n* 大致题意：给出 $n$ 个数，为 $1$ 到 $n$ 的排列，有 $m$ 个询问，第 $i$ 个询问给出 $k_i$ 个数，对于每个询问，输出随即从这 $k_i$ 个数中取出两个数 $l$ , $r$ ( $l\\leq r$ ) ，原数组在区间 $[l,r]$ 的范围内的最大值有几种情况，假设每次取数都是随机的，每种情况的概率分别是多少，用暨约分数来表示。每个数据的范围都在 1e5，保证查询给出的数的总数量不超过 1e5\n\n* 题解：每次询问都给定了可以作为边界的的数，首先考虑最大值所有的可能，一个区间的最大值必定是它所有小的子区间的最大值的最大值，所以每次可以先对给出的数排序，两两为开边界组成的内区间的最大值和边界值是所有可能的最大值情况，一共有 $2n-1$ 个，因为题目给的是排列，所以保证了这些数互不相同，数据范围允许枚举，查询区间最大值用 ST 表操作即可，对于每个最大值，可以查询它的作用范围，用单调栈预处理即可，然后 $lower\\_bound$ 出每次询问对应的区间范围，对于取区间最大值和端点值得情况可以分类讨论，保证不会出错。总复杂度$O(n\\log n)$。\n\n  ps：感觉这个大数据结构题还是很有训练运用数据结构解决问题的能力的，我这个菜鸡因为写错 $st$ 表 $de$ 了好久 $bug$ ，不过还是学到了不少。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+13;\nint lm[maxn],rm[maxn];//左单调栈和右单调栈\nint st[maxn][30],s[maxn];//一个st表，一个栈\nint lg[maxn],a[maxn],v[maxn];\nll ans[maxn]; \nvector<int> rb;\nint query(int l,int r){\n\tint k=lg[r-l+1];\n\treturn max(st[l][k],st[r-(1<<k)+1][k]);\n} \nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tlg[0]=-1;\n\tfor(int i=1;i<=100000;i++) lg[i]=lg[i>>1]+1; \n\tfor(int i=1;i<=n;i++) st[i][0]=a[i];\n\tfor(int i=1;i<=21;i++){\n\t\tfor(int j=1;j+(1<<i)-1<=n;j++){\n\t\t\tst[j][i]=max(st[j][i-1],st[j+(1<<(i-1))][i-1]);\n\t\t}\n\t}\n\tint top=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(top&&a[i]>a[s[top]]){\n\t\t\trm[a[s[top]]]=i;\n\t\t\ttop--;\n\t\t} \n\t\tif(!top||(top&&a[s[top]]>=a[i])){\n\t\t\ts[++top]=i;\n\t\t}\n\t}\n\twhile(top) rm[a[s[top]]]=n+1,top--;\n\tfor(int i=n;i>=1;i--){\n\t\twhile(top&&a[i]>a[s[top]]){\n\t\t\tlm[a[s[top]]]=i;\n\t\t\ttop--;\n\t\t} \n\t\tif(!top||(top&&a[s[top]]>=a[i])){\n\t\t\ts[++top]=i;\n\t\t}\n\t}\n\twhile(top) lm[a[s[top]]]=0,top--;\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trb.clear(); \n\t\tfor(int i=1;i<=k;i++) scanf(\"%d\",&v[i]);\n\t\tsort(v+1,v+1+k);\n\t\tll tot=1ll*k*k;\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint mx;\n\t\t    mx=a[v[j]]; \n\t\t\tint l=lm[mx]+1;\n\t\t\tint r=rm[mx]-1;\n\t\t\tint LL=lower_bound(v+1,v+1+k,l)-v;\n\t\t\tint rr=lower_bound(v+1,v+1+k,r+1)-v;\n\t\t\tint mid=j;\n\t\t\tans[mx]+=1ll*2*(mid-LL+1)*(rr-mid)-1;\n\t\t\tif(ans[mx]) rb.push_back(mx); \n\t\t\tif(v[j]+1<=v[j+1]-1&&j<k){\n\t\t\t\tmx=query(v[j]+1,v[j+1]-1);\n\t\t\t\tl=lm[mx]+1;\n\t\t\t    r=rm[mx]-1;\n\t\t\t    LL=lower_bound(v+1,v+1+k,l)-v;\n\t\t\t    rr=lower_bound(v+1,v+1+k,r+1)-v;\n\t\t\t    ans[mx]+=1ll*2*(j-LL+1)*(rr-j-1);\n\t\t\t\tif(ans[mx]) rb.push_back(mx); \n\t\t\t} \n\t\t}\n\t\tsort(rb.begin(),rb.end());\n\t\tfor(int i=0;i<rb.size();i++){\n\t\t\tll cut=__gcd(ans[rb[i]],tot);\n\t\t\tprintf(\"%d %lld/%lld\\n\",rb[i],ans[rb[i]]/cut,tot/cut);\n\t\t\tans[rb[i]]=0;\n\t\t}\n\t}\n}\n```\n\n\n\n### B \n\n* 大致题意：暂时没做\n* 题解：暂时没补\n\n### C\n\n* 大致题意：定义字符串的长度为 $k$ 的 $border$ 为字符串 $S$ 的一个前缀，满足 $S_0S_1S_2…S_{k-1}$ 和 $S_{n-k}S_{n-k+1}S_{n-k+2}…S_{n-1}$ 完全相同。先给出长度为 $n$ 的字符串，再给出数字 $k$，问如果要使得该字符串满足拥有长度为 $k,2k,…,\\lfloor\\frac{n}{k}\\rfloor*k$ 的 $border$ ，它至少需要改变多少位置的字符，输出改变后的字符串。\n\n* 题解：可以盲猜把这个字符串搞成拥有一个长度为 $t$ 的字符串为循环节的字符串，这题需要分类讨论，若 $2*k>n$ ,则 $t$ 为 $n-k$ ，画个图就能一目了然，对于其他情况，参考下面的图（偷过来的）\n\n  ![](\\images\\nowcoder 2-1.png)\n\n  开头空出来的部分，易知长度为 $n\\%k$ ，循环节 $t$ 必定是 $n\\%k$ 的因数，同时为了保证对于每个 $k$ 的倍数都是成立，循环节 $t$ 还必须是 $k$ 的因数，这些都能从图上看出来。为保证修改量最小，循环节要尽可能大，所以这种情况 $t =\\gcd(n\\%k,k)=\\gcd(n,k)$ 。求出循环节后，遍历每个对应位置的数取众数为替代的字符即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nint cnt[27];\nchar s[maxn];\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n,l;\n\t\tscanf(\"%d%d\",&n,&l);\n\t\tscanf(\"%s\",s+1);\n\t\tint m=(2*l<=n)?__gcd(n,l):n-l;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t    for(int j=i;j<=n;j=j+m){\n\t\t    \tcnt[s[j]-'a']++;\n\t\t\t}\n\t\t\tint now=0,mx=0;\n\t\t\tfor(int j=0;j<=25;j++){\n\t\t\t\tif(cnt[j]>mx){\n\t\t\t\t\tmx=cnt[j];\n\t\t\t\t\tnow=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=i;j<=n;j=j+m) s[j]='a'+now;\n\t\t} \n\t\tprintf(\"%s\\n\",s+1);\n\t}\n } \n```\n\n### D\n\n* 大致题意：令 $S$ 为 $S=\\{x:x=\\lfloor\\frac{n}{i}\\rfloor,i=1,2…n\\}$ ，现在将 $S$ 中元素降序排列，给出 $n$，$x$ ,问 $\\lfloor\\frac{n}{x}\\rfloor$ 在 $S$ 中排名第几？\n* 题解：一开始以为这玩意是数论，结果是个找规律的题，题目给出了一组样例，对于 $n=25$ 的情况，$S=\\{25,12,8,6,5,4,3,2,1\\}$ ，会发现对于 $x\\leq\\sqrt{n}$ 的情况，是一一对应的，对于 $x>\\sqrt{n}$ 的情况，每个 $\\lfloor\\frac{n}{x}\\rfloor$ 都可以与之前 $x\\leq\\sqrt{n}$ 情况得到的值相对应，所以，所以 $\\lfloor\\frac{n}{x}\\rfloor$ 是几，它右边就有多少个数，用总数减去它即可，根据这个性质可以计算出答案，注意，对于 $\\frac{n}{tmp}=tmp (tmp=\\lfloor\\sqrt{n}\\rfloor)$ 的情况，总数需要减一。\n\n### E\n\n* 大致题意：一个人需要在 $n$ 块矩形上行走，第 $i$ 个矩形长为 $x_i$ ，所有矩形宽都为 $1$ ，矩形相接排布，矩形每条边都与坐标轴平行，若两个矩形之间接触边长度不为 $0$ ，则这个人可以在这两个矩形之间移动，问这个人从矩形 $1$ 移动到矩形 $n$ 至少需要越过多少个矩形。\n* 题解：基本就是个建图跑最短路的题，但是数据范围不允许 $n^2$ 遍历建图，所以考虑双指针法处理，对于左右相连的矩形，可以直接一个一个枚举判断，对于上下相连的矩形，对于每两个横坐标 $i,i+1$ ，维护两个指针 $l,r$ 表示当前遍历到的矩形编号，若 $l$ 矩形的右边界大于 $r$ 矩形右边界，则推进 $r$ ,反之推进 $l$ 。\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nconst int maxn=1e5+13;\nint dis[maxn],vis[maxn];\nstruct node{\n\tint l,r,id;\n}; \nbool operator <(node a,node b){\n\treturn a.l<b.l;\n}\nvector<node> v[maxn];\nvector<int> p[maxn];\nqueue<int> q;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint my=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint y,l,r;\n\t\tscanf(\"%d%d%d\",&y,&l,&r);\n\t\tv[y].push_back((node){l,r,i});\n\t\tmy=max(my,y);\n\t}\t\n\tfor(int i=0;i<=my;i++){\n\t\tsort(v[i].begin(),v[i].end());\n\t}\n\tfor(int i=0;i<=my;i++){\n\t\tif(v[i].empty()) continue;\n\t\tfor(int j=0;j<v[i].size()-1;j++){\n\t\t\tif(v[i][j].r==v[i][j+1].l){\n\t\t\t\tint id1=v[i][j].id,id2=v[i][j+1].id;\n\t\t\t\tp[id1].push_back(id2);\n\t\t\t\tp[id2].push_back(id1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<my;i++){\n\t\tif(v[i].empty()||v[i+1].empty()) continue;\n\t\tint l=0,r=0;\n\t\twhile(r<v[i+1].size()&&l<v[i].size()){\n\t\t\tif(v[i+1][r].r>v[i][l].l&&v[i+1][r].l<v[i][l].r){\n\t\t\t\tint id1=v[i][l].id,id2=v[i+1][r].id;\n\t\t\t\tp[id1].push_back(id2);\n\t\t\t\tp[id2].push_back(id1);\n\t\t\t}\n\t\t\tif(v[i+1][r].r<v[i][l].r) r++;\n\t\t\telse l++;\n\t\t}\n\t}\n\tq.push(1);\n\tvis[1]=1;\n\tdis[1]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<p[now].size();i++){\n\t\t\tint v=p[now][i];\n\t\t\tif(vis[v]) continue;\n\t\t    dis[v]=dis[now]+1;\n\t\t\tq.push(v);\n\t\t\tvis[v]=1; \n\t\t}\n\t}\n\tprintf(\"%d\",dis[n]);\n } \n```\n\n\n\n### F\n\n* 大致题意：给出一段 $1-n$ 的排列，首先选定长度 $k$ ，规定每次可以选择一个下标 $i$ ，每次可以将包含下标 $i$ 在内的连续长度为 $k$ 的字符串整体翻转，规定每次选择的下标必须逐次递增。问能否通过有限次操作使该排列有序。\n* 题解：题目要求每次选择的下标必须递增，说明每次翻转之后被移到前面的数字一定是被固定下来的，对于前面的位置而言，必须每次把对应的数字移过去，所以很快啊~，$k$ 就出来了，之后只要验证每次是否都可以通过翻转长度为 $k$ 的字符串来让前面的位置出现应该出现的数。由于每次翻转的区间固定，所以可以使用双端队列来维护，每次将第一个数字（已经排好）出队，在末尾加入新的数字，查询现在队首和队尾的数字是否满足条件，用一个标记来记录当前是否已经翻转，若现在是反转状态，则对队首的操作改为队尾，对队尾的操作改为队首即可。最后判断队列中剩下的数是否与相应位置一一对应即可。\n\n### G\n\n* 大致题意：$n$ 支队伍参加一场比赛，比赛一共有 $m$ 道题，每道题做出来的队伍编号是一段连续的区间 $[l,r]$ ，现在规定比赛的奖牌线为排名为$\\lceil\\frac{n}{9}\\rceil$，$\\lceil\\frac{n}{4}\\rceil$，$\\lceil\\frac{n}{2}\\rceil$ 的人所通过的题目数，而且奖牌的题目线不得低于 $1$ ，问最后获得金银铜牌的人各有多少？($n\\leq1e5 ,l,r\\leq1e9$)\n* 题解：乍一看不是差分嘛，一看数据范围，大意了没有闪。题目目标求的是获得金银铜牌的人数，而且金银铜牌的评定准则是通过了多少题，所以计算出通过 $i$ 题的人各有多少个问题就解决了。因为数据范围很大不能用桶来实现差分，所以就离散化后用扫描线处理，先记录下对于每个点的改变值，然后排序，依次统计前缀和，由下一个和当前这一个之间的个数差可以 $O(1)$ 处理出获得当前统计到的奖牌数的人有多少。最后按照题目数从大到小枚举，查询每个奖牌的规定排名对应的题目数量即可（注意题目数量要和 $1$ 取最大值）\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nconst int maxn=2e5+13;\npair<int,int> op[maxn];\nint sum[maxn];//统计每个牌子有多少队 \nint cal[maxn];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint g,s,d,cnt=0;\n\tg=(n+9)/10;\n\ts=(n+3)/4;\n\td=(n+1)/2;//金银铜人数限 \n\tfor(int i=1;i<=m;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\top[++cnt].fi=l,op[cnt].se=1;\n\t\top[++cnt].fi=r+1,op[cnt].se=-1;\n\t}\n\tsort(op+1,op+1+cnt);\n\tint tot=0;\n\tfor(int i=1;i<=cnt;i++){\n\t\ttot+=op[i].second;\n\t\tif(i<cnt&&op[i].fi!=op[i+1].fi){\n\t\t\tsum[tot]+=op[i+1].fi-op[i].fi;\n\t\t}\n\t}\n\ttot=0;\n\tint gt,st,dt;\n\tfor(int i=m;i>=0;i--){\n\t\tif(tot<g) gt=i;\n\t\tif(tot<s) st=i;\n\t\tif(tot<d) dt=i;\n\t\ttot+=sum[i];\n\t\tcal[i]=cal[i+1]+sum[i]; \n\t}\n\tgt=max(1,gt);\n\tst=max(st,1);\n\tdt=max(dt,1);\n\tprintf(\"%d %d %d\",cal[gt],cal[st]-cal[gt],cal[dt]-cal[st]);\n } \n```\n\n### H\n\n* 大致题意：按要求输出一个正方形字符阵列，规定 $1$ 周边全是 $0$ ，$0$ 周边全是 $1$ \n* 题解：签到题，按照 $(i+j)\\&1$ 来输出即可。\n\n### I\n\n* 大致题意：定义函数 $F(x)$ 表示将x做质因数分解后得到的数字从小到大升序排列，然后将其组成一个大整数，如 $F(1500)=223555$ ,现在给定 $n$ ,要求计算 $\\sum_{i=2}^nF(i)$\n\n* 题解：这题考察灵活应用线性筛，众所周知线性筛十分典型的一个性质是所有合数都会被它最小的素数筛出来，而且每一个合数只会被筛出一次，所以可以利用这个性质进行 $dp$ ,用 $tt[i]$ 表示当数的位数，$ans[i]$ 表示当前这个数对应的答案，在每次筛出新素数时初始化数组，筛出合数时更新答案即可，最后将 $ans[i]$ 累加就得到答案了。\n\n```c++\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=4e6+13;\nint p[maxn+13],vis[maxn+13];\nint dp[maxn][30];\nint pw[maxn];\nint cal[maxn],tt[maxn];\nint ans[maxn];\nint get(int x){\n\tint cal=0;\n\twhile(x){\n\t\tx/=10;\n\t\tcal++;\n\t}\n\treturn cal;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=1ll*pw[i-1]*10%mod;\n\tint cnt=0;\n\tvis[0]=vis[1]=1;\n\tint ed=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!vis[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tans[i]=i;\n\t\t\ttt[i]=get(ans[i]);\n\t\t}\n\t\ted=1ll*(ed+ans[i])%mod;\n\t\tfor(int j=1;j<=cnt&&p[j]*i<=n;j++)\n\t\t{\n\t\t\tvis[p[j]*i]=1;\n\t\t\tans[p[j]*i]=1ll*(ans[i]+1ll*pw[tt[i]]*p[j]%mod)%mod;\n\t\t\ttt[p[j]*i]=tt[i]+tt[p[j]];\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t} \n\tprintf(\"%d\",ed);\n}\n```\n\n### J\n\n* 大致题意：对于从 $n$ 个数中找出三个数作为三角形的三条边的问题，有一段如下图的暴力代码，请构造数据 $hack$ 它。\n\n  ```c\n  FOR i = 1 ... n\n      FOR j = i + 1 ... n\n          FOR k = j + 1 ... n\n              IF isTriangle(a[i],a[j],a[k])\n                  print(\"yes\")\n                  EXIT\n              END IF\n          END FOR\n      END FOR\n  END FOR\n  print(\"no\")\n  EXIT\n  ```\n\n* 题解：这段代码的理论复杂度$O(n^3)$ 的，但是好像其实会很快，下次我也拿这个去~~忽悠学弟~~，题目规定要将调用 $isTriangle$ 函数的次数放在 $min(C_n^3,n^2\\log n)$ 以上，其实对于大数据只要保证它至少有 $n^2\\log n$ 就行，注意到，只要前面几个数，假设有 $k$ 个，保证任选三个都组不成三角形，而且前面的数和后面的数三三之间也组不成三角形，调用次数就能保证在 $kn^2$ 级别，所以考虑取 $k=35$ ，构造思路就是在前面放 $35$ 个$2,3$ 开头斐波那契数列，后面全部都放 $1$ 。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nint a[maxn];\nint main()\n{\n   int n;\n   scanf(\"%d\",&n);\n   a[1]=2,a[2]=3;\n   for(int i=3;i<=35;i++){\n   \ta[i]=a[i-1]+a[i-2];\n   }\n   if(n<=35){\n   \tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]);\n   \treturn 0;\n   }\n   else{\n   \tfor(int i=1;i<=35;i++) printf(\"%d \",a[i]);\n   \tfor(int i=36;i<=n;i++) printf(\"1 \");\n   }\n} \n```\n\n","tags":["牛客"],"categories":["算法","刷题"]},{"title":"2021牛客寒假算法基础集训营1","url":"/2021/02/07/2021牛客寒假算法基础集训营1/","content":"\n## 2021牛客寒假算法基础集训营1\n\n<!-- more -->\n\n### A\n\n* 大致题意：问所有包含子串 \"us\" 的字符串有多少个，子串中 “us” 可以不连续。\n* 题解：$dp$， $dp[i][0],dp[i][1],dp[i][2]$ 分别表示还未出现过 \"u\" ,出现过 \"u\" 但还未出现过 ”s“ 的字符串个数，转移方程很好写，然后转移即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+13;\nconst int mod=1e9+7;\nint dp[maxn][3];//出现过u了嘛，出现过s了嘛\nint main()\n{\n    int n;\n    dp[0][0]=1;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        dp[i][0]=(dp[i][0]+1ll*dp[i-1][0]*25%mod)%mod;\n        dp[i][1]=1ll*(dp[i][1]+dp[i-1][0])%mod;\n        dp[i][1]=(dp[i][1]+1ll*dp[i-1][1]*25%mod)%mod;\n        dp[i][2]=1ll*(dp[i][2]+dp[i-1][1])%mod;\n        dp[i][2]=(dp[i][2]+1ll*dp[i-1][2]*26%mod)%mod;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++) ans=1ll*(ans+dp[i][2])%mod;\n    printf(\"%d\",ans);\n}\n```\n\n### B\n\n* 大致题意：构造一个非空的括号字符串，包含正好 $k$ 个不同合法括号对。\n* 题解：首先不难发现，如果构造出来的字符串左边有且仅有 $k_1$ 个左括号，右边有且仅有$k2$ 个右括号，那么最后可以得到总括号对数为 $k_1*k_2$ ，所以可以先在左边画 $\\sqrt{k}$ 个左括号，然后右边补右括号补齐到不能补为止，最后看差了几个，就在前面第几个左括号后插右括号就好\n\n### C\n\n* 大致题意：要给一颗树上的每一个点染色，规定要实现每个红点周边连接的点的颜色有且只有一个是蓝色，每个蓝点周边连接的点的颜色有且只有一个是红色，问存不存在一种染色方案。\n* 题解：可以知道对于每个叶节点，只有一个点与之相连，所以这个点和其父节点颜色必定相同，而父节点颜色定了后，其周边节点的颜色又必须和它不一样，所以可以采取一种$dfs$ 的策略，从根节点向下 $dfs$ 遇到叶节点或者是未被标记过的节点，就将这个节点与其父节点用同一个数标记，表示两节点颜色相同，如果遇到一个节点还没标记但是父节点已经被标记，则说明该节点附近不会有和它相同颜色的点，则不成立，若成立，最后第二次 $dfs$ 处理一下答案即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+13;\nint f[maxn];\nint ans[maxn];\nvector<int> p[maxn];\nint bingo;\nint cnt;\nvoid dfs1(int rt,int fa){\n\tint yes=0;\n\tfor(int i=0;i<p[rt].size();i++){\n\t\tint v=p[rt][i];\n\t\tif(v==fa) continue;\n\t\tyes=1;\n\t\tdfs1(v,rt);\n\t}\n\tif(!yes||!f[rt]){\n\t\tif(f[fa]) bingo=1;\n\t\telse f[fa]=f[rt]=++cnt;//如果是叶子节点或者没被标记过则和发节点一样 \n\t}\n}\nvoid work(int rt,int fa){\n    for(int i=0;i<p[rt].size();i++){\n    \tint v=p[rt][i];\n    \tif(v==fa) continue;\n    \tif(f[v]==f[rt]) ans[v]=ans[rt];\n    \telse ans[v]=ans[rt]^1;\n\t\twork(v,rt); \n\t}\n} \nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tp[u].push_back(v);\n\t\tp[v].push_back(u);\n\t}\n\tdfs1(1,0);\n\tif(f[0]||bingo){\n\t\treturn printf(\"-1\"),0;\n\t}\n\tans[1]=0;\n\twork(1,0);\n\tfor(int i=1;i<=n;i++) printf(ans[i]?\"R\":\"B\");\n} \n```\n\n\n\n### D\n\n* 大致题意：给定一个 $n*n$ 的矩阵，矩阵中的元素只有 $0$ 和 $1$ ，规定每次对一个矩阵中的$1$ 进行一次操作可以将包含它的\"1连通块\"中的数全部变成 $0$ ,问有多少不同的操作数可以将矩阵中的数全变成 $0$，如果每次把矩阵中一个坐标上的数 $0$ 变成 $1$ ，答案又是多少？\n* 题解：并查集维护连通块，假设现在有 $k$ 个连通块，答案就是 $k!\\prod_{i=1}^{k}sz_i$ ，每次加一个$1$ ,先增加一个连通块，然后查询它周围是否有 $1$ ,有就并入该连通块，连通块减一，每次计算一次答案即可。\n\n### E\n\n* 大致题意：几何题，问在棱长为 $a$ 三棱锥重心，向距离中心不超过 $r$ 的地方涂色，问最后被涂有颜色的面积为多大。\n\n​    ![](/images/nowcoder 1-1.jpg)\n\n* 题解：几何分析题，核心是要算出三棱锥重心到底面的距离，这个可以用体积关系去算，需要画图讨论，具体不想多说了……。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst double pi=acos(-1);\ndouble eps=1e-7;\nint main()\n{\n\tdouble a,r;\n\tscanf(\"%lf%lf\",&a,&r);\n\tif(r*r-a*a/24<-eps){\n\t\treturn printf(\"0\"),0;\n\t} \n\tif(r*r-a*a/24<=a*a/12){\n\t\tprintf(\"%.7lf\",4.0*(r*r-a*a/24)*pi);\n\t}\n\telse if(r*r-a*a/24<a*a/3){\n\t\tdouble rr=sqrt(r*r-a*a/24);\n\t\tdouble ed=2*pi/3-2*acos(sqrt(3.0)*a/(6*rr));\n\t\tdouble ans=sqrt(rr*rr-a*a/12)*sqrt(3.0)*a/6+ed*rr*rr/2.0;\n\t\tprintf(\"%.7lf\",ans*12.0); \n\t}\n\telse{\n\t\tprintf(\"%.7lf\",sqrt(3.0)*a*a);\n\t}\n } \n```\n\n### F\n\n* 大致题意：有两个人做 $n$ 道选择题，每道选择题有 $4$ 个选项，做对一题可以得 $1$ 分，现在给出这两个人这 $n$ 道题的选择，问他们总共最高和最低能得多少分。\n* 题解：签到题，显然最坏得 $0$ 分，最好情况下，两人选项不一样就有一个人对，得一分，选项一样就两人都对，得两分，统计最后答案即可。\n\n### G\n\n* 大致题意：大 模 拟\n\n* 题解：太长了，爬\n\n### H\n\n* 大致题意：求底数为 $a$ ,阶数为 $n$ 的幂塔个位数是什么，所谓幂塔，是形如下面这种形式的数\n\n  ![](/images/equation.svg)\n\n* 题解：可以用欧拉定理降幂，因为只涉及模10，所以可以不用去管乘除的复杂度，直接使用最普遍的欧拉公式\n  $$\n  a^p\\equiv a^{p\\%\\varphi(t)+\\varphi(t)}\\mod t\n  $$\n  降幂即可，至于大数的乘除，可以交给 $python$ 处理，写个处理的递归函数即可。\n\n```python\ndef phi(x):\n    if x==10:\n        return 4\n    if x==4:\n        return 2\n    if x==2:\n        return 1\n    if x==1:\n        return 1\n\ndef work(a,b,mod):\n    if mod==1:\n        return 1\n    if b==1:\n        return a%mod+mod\n    return pow(a,work(a,b-1,phi(mod)),mod)+mod\n\na = int(input())\nb = int(input())\nif b==1:\n    print(a%10)\nelse:\n    print(pow(a,work(a,b-1,phi(10)),10))\n\n\n```\n\n### I\n\n* 大致题意：构造一个长度为 $n$ 的排列，满足正好有 $k$ 对相邻的数满足最大公约数大于 $1$ 。$k$ 的范围小于等于 $\\frac{n}{2}$\n* 题解：可以证明，两个相邻偶数必定公约数大于 $1$ （废话），两个相邻奇数必定互质，两相邻自然数也必定互质，可以根据这个性质构造，如果 $k$ 小于 $\\frac{n}{2}$ ，就从小到大拿出 $k+1$ 个偶数放在一起，再从左向右依次放没出现过的数。如果 $k$ 等于 $\\frac{n}{2}$ 会发现拿不出那么多的偶数，考虑最小的与偶数不互质的奇数为 $3$ ，那么可以在枚举所有偶数的时候把 $6$ 单独拿出来放在最后，在最后放 $3$ ，如果少于 $6$，就不存在这样的构造。\n\n### J\n\n* 大致题意：求出所有比 $n$ 小的数且素因数不止一个（也就是不是素数幂形式的数）的数的最小公倍数。\n\n* 题解：线性筛出比 $n$ 小的所有的素数，然后其实求 $lcm$ 只要找到每个素因子可能的最大指数就行了，对于素因子2，找出最大的 $k$，满足 $3*2^k\\leq n$ 即可，对于其他素因子 $p_i$，找出最大的 $k$ ,满足 $p_i^k*2\\leq n$ ，然后将他们乘起来就是答案。一开始我一直觉得会t，后来发现其实复杂度小于 $O(\\frac{n}{\\log n}*\\log n)$ 即 $O(n)$，因为 $n$ 以内的素数数量是 $\\frac{n}{\\log n}$ 级别的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=8e7+13;\nint p[maxn+13];\nint vis[maxn+13];\nint main()\n{\n    int n,cnt=0;\n    scanf(\"%d\",&n);\n\tvis[0]=vis[1]=1;\n\tfor(int i=2;i<=maxn;i++)\n\t{\n\t\tif(!vis[i]) p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&1ll*p[j]*i<=maxn;j++)\n\t\t{\n\t\t\tvis[p[j]*i]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=cnt;i++){\n\t\tll k;\n\t\tif(p[i]==2) k=3;\n\t\telse k=2;\n\t\twhile(k*p[i]<=n){\n\t\t\tif(!ans) ans=1;\n\t\tk=1ll*k*p[i],ans=1ll*ans*p[i]%mod;\n\t    }\n\t}\n\tif(!ans) printf(\"empty\");\n    else printf(\"%d\",ans);\n } \n```\n\n\n\n","tags":["牛客"],"categories":["算法","刷题"]},{"title":"做题记录1.31","url":"/2021/01/31/做题记录1-31/","content":"\n## AtCoder Beginner Contest 190\n\n<!-- more -->\n\n### D\n\n* 大致题意：求又多少个连续整数列，满足和为 $n$ \n* 题解：看似组合题，其实是数论，设起点为 $x$，终点为 $y$。则由等差数列数列求和公式可以算出和为 $\\frac{(x+y)(y-x+1)}{2}$ ，所以也就是 $(x+y)(y-x+1) =2n$ ,对 $2n$ 分解因数即可，然后看看能否解出正常的 $x$，$y$ 值即可。\n\n### E\n\n* 大致题意：给出 $n$ 个数排列，再给出 $m$ 对数，规定排列的时候只有给定的一对数才能靠在一起，现在给出 $k$ 个数，现在要按上述规章实现一个包含这 $k$ 个数的排列，问这个排列最短是多少？\n* 题解：$k$ 只有 $17$ ，可以通过状压 $dp$ 来解决，$dp[i][j]$ 表示状态为 $i$ 以 $j$ 结束的最短排列，容易列出方程 $dp[next][j]=min(dp[next][j],dp[i][z]+dis[z][j])$ ，$dis$ 数组可以通过 $01bfs$ 求出。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3e5+13;\nll dp[maxn][20];\nint dis[20][maxn];\nint vis[maxn];\nqueue<int> q;\nvector<int> p[maxn];\nint c[maxn];\nvoid bfs(int id,int x){\n\tmemset(vis,0,sizeof(vis));\n\tq.push(x);\n\tdis[id][x]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<p[now].size();i++){\n\t\t\tint v=p[now][i];\n\t\t\tif(vis[v]) continue;\n\t\t\tdis[id][v]=dis[id][now]+1;\n\t\t\tq.push(v);\n\t\t\tvis[v]=1; \n\t\t}\n\t}\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tp[a].push_back(b);\n\t\tp[b].push_back(a);\n\t}\n\tmemset(dis,0x3f,sizeof(dis));\n\tint k;\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++) scanf(\"%d\",&c[i]),bfs(i,c[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tfor(int i=0;i<k;i++) dp[1<<i][i]=1;\n\tfor(int i=1;i<(1<<k);i++){\n\t\tfor(int z=0;z<k;z++){\n\t\t\tif(((i>>z)&1)){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tif(!((i>>j)&1)) dp[i|(1<<j)][j]=min(dp[i|(1<<j)][j],dp[i][z]+dis[z+1][c[j+1]]);\n\t\t\t}\n\t\t }\n\t\t}\n\t}\n\tll ans=1e9;\n\tfor(int i=0;i<k;i++) ans=min(dp[(1<<k)-1][i],ans);\n\tif(ans>=1e9) printf(\"-1\");\n\telse printf(\"%d\",ans);\n }\n```\n\n### F\n\n* 大致题意：给定一个序列 $a$ ,问它的逆序对个数，以及对它进行 $0,1,2……,n-1$ 次循环左移（就是把第一个数放在最后，其他数往前移一格）后的逆序对数。\n* 题解：对于后面移动的情况，只要维护当前第一个数对于总逆序对数的贡献即可，本质上是 $logn$ 查询区间内比一个数大或者比一个数小的数的个数，可以用主席树来维护（或者可以平衡树？太麻烦了不想写~），每次把第一个数放到最后只要对主席树进行扩展即可，每次做区间的查询。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3e5+13;\nint a[maxn],lc[maxn<<6],rc[maxn<<6],sum[maxn<<6];\nint t[maxn<<2];\nint p;\nvoid build(int &rt,int l,int r){\n\tif(!rt) rt=++p;\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tbuild(lc[rt],l,mid);\n\tbuild(rc[rt],mid+1,r);\n}\nvoid modify(int &rt,int pre,int l,int r,int x){\n\trt=++p;\n\tlc[rt]=lc[pre],rc[rt]=rc[pre],sum[rt]=sum[pre]+1;\n\tif(l>=r) return;\n\tint mid=l+r>>1;\n\tif(x<=mid) modify(lc[rt],lc[pre],l,mid,x);\n\telse modify(rc[rt],rc[pre],mid+1,r,x);\n}\nint qbig(int rt,int pre,int l,int r,int x){\n\tif(l==r){\n\t\treturn sum[rt]-sum[pre];\n\t}\n\tint mid=l+r>>1;\n\tif(x<=mid) return qbig(lc[rt],lc[pre],l,mid,x)+sum[rc[rt]]-sum[rc[pre]];\n\telse return qbig(rc[rt],rc[pre],mid+1,r,x); \n}\nint qsmall(int rt,int pre,int l,int r,int x){\n\tif(l==r){\n\t\treturn sum[rt]-sum[pre];\n\t}\n\tint mid=l+r>>1;\n\tif(x>mid) return qsmall(rc[rt],rc[pre],mid+1,r,x)+sum[lc[rt]]-sum[lc[pre]];\n\telse return qsmall(lc[rt],lc[pre],l,mid,x); \n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),modify(t[i],t[i-1],0,n-1,a[i]);\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=1ll*qsmall(t[n],t[i],0,n-1,a[i]-1);\n\t}\n\tprintf(\"%ld\\n\",ans);\n\tfor(int i=1;i<=n-1;i++){\n\t\tans-=1ll*qsmall(t[n+i-1],t[i],0,n-1,a[i]-1);\n\t\tans+=1ll*qbig(t[n+i-1],t[i],0,n-1,a[i]+1);\n\t\tmodify(t[n+i],t[n+i-1],0,n-1,a[i]);\n\t\tprintf(\"%lld\\n\",ans); \n\t}\n } \n```\n\n","tags":["atcoder"],"categories":["算法","刷题"]},{"title":"做题记录1.30","url":"/2021/01/30/做题记录1-30/","content":"\n## Educational Codeforces Round 103\n\n<!-- more -->\n\n### B\n\n* 大致题意：给定数组 $p$ ，表示价格变化，$p_i$表示第 $i$ 个月的加格增长量，现在可以对 $p$ 中的任意数进行增大操作，要保证每个月加格增长幅度小于百分之 $k$ ，问最少的增加总和是多少？\n* 题解：增加总和最小，最有策略一定是将要增加的量全部加在第一个数上，因为对第一个数增加，既增加了总量又能保证不对接下来的结果产生影响，因此代价一定是最优的，之后对每个月计算如果满足条件至少需要加多少价格，同时更新前缀和。要满足 $\\frac{p_i}{sum}\\le\\frac{k}{100}$ ,所以假如有 $\\frac{p_i}{sum}>\\frac{k}{100}$ ，可以直接计算 $\\lceil\\frac{100*p_i-k*sum}{k}\\rceil$ 获得每一部分的贡献。\n\n### C\n\n* 大致题意：给定 $n$ 条链，第 $i$ 条链由 $c_i$ 个点组成，对于每条链，编号为 $1$ 的点与上一条链编号为 $a_i$ 的点之间有一条无向边，编号为 $c_i$ 的点与上一条编号为 $b_i$ 的点相连，第一条链的 $a_i$，$b_i$默认都是 $-1$，问最后形成的图上最长的环的阶是多少。\n\n  ![](/images/edu103C.jpg)\n\n* 题解：对于每条链进行 $dp$，可以发现枚举每个链，可以做出两种选择，选择上一条链的$a_i$ 与 $b_i$ 之间的几条边作为新的起点，或者选则之前处理的半环，然后加上与上一条链相连的两条边，这两者的选择取个最大值就好了，并计算假如在这个链就结束能得到的答案和 $ans$ 取最大值，更新维护新的半环对旧半环的贡献，并向后枚举 $dp$ 。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+13;\nll a[maxn],b[maxn],c[maxn],dp[maxn];\nint main()\n{\n   int t;\n   scanf(\"%d\",&t);\n   while(t--){\n   \tint n;\n   \tscanf(\"%d\",&n);\n   \tfor(int i=1;i<=n;i++) scanf(\"%lld\",&c[i]);\n   \tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n   \tfor(int i=1;i<=n;i++) scanf(\"%lld\",&b[i]);\n   \tint ob=0;\n   \tll ans=0,now=0;\n   \tfor(int i=2;i<=n;i++)\n   \t{\n   \t\tll x=max(a[i],b[i]);\n   \t\tll y=min(a[i],b[i]);\n   \t\tif(x==y){\n   \t\t\tdp[i]=0;\n\t\t   }\n   \t\telse dp[i]=max(dp[i-1],x-y);\n   \t\tans=max(ans,dp[i]+2+c[i]-1);\n   \t\tif(i<n) dp[i]+=2+c[i]-1-(max(a[i+1],b[i+1])-min(a[i+1],b[i+1]));\n\t   }\n\tprintf(\"%lld\\n\",ans);\n   } \n}\n```\n\n### D\n\n* 大致题意：有 $n+1$ 个城市，给定一个长度为 $n$ 的由 $L$ 和 $R$ 组成的字符串，对于城市 $i$ 若第 $i$ 个字符是 $L$ ,则可以从这个城市出发到城市 $i-1$ ，如果第 $i+1$ 个字符为 $R$ ，则可从这个个城市出发达到城市 $i+1$ ，规定每一定动一次，字符串都会反转一次（ $L$ 变成$R$ ，$R$ 变成 $L$ ），问从从这 $n+1$ 个城市出发各自能够拜访的最大城市数量是多少？\n* 题解：从一个城市出发能够到达的城市由向右走可以到达的城市数量和向左走可以到达的城市数量组成，不管是向左还是向右走，不难发现形如“RLRLRL”这样才能持续走，所以计算向右可以从右向左 $dp$ ，统计上面这种字符串累积的数量，当然如果向右时遇到第一个字符为 $L$ ，则向右得贡献显然就是0，向左同理，计算向左可以从左往右统计，最后答案需要加上自己。\n\n### E\n\n* 大致题意：先给出 $m$ 个模式串，该字符串由下划线和小写英文字母组成，再给出n个完全由小写英文字母组成的字符串，每个字符串旁跟着一个数字 $mt_i$，规定下划线为通配符，现在要给出模式串的一个排列，使得对于每个字符串而言排列中从左向右第一个与它批配的模式串的编号正好为 $mt_i$，或者输出不存在。\n* 题解：对于一个字符串，可以有多个模式串与之相匹配，而规定 $mt_i$ 必须在其他的与字符串匹配的模式串前，对于这种强调依附性关系的序，可以用拓扑排序解决，由 $mt_i$ 向其他的模式串编号连一条有向边，然后对这些点拓扑排序即可。找到与每个字符串匹配的模式串集合可以通过对模式串建字典树解决。若没有匹配的，$mt_i$ 模式串不与字符串相匹配，以及拓扑排序失败的情况都是无解。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+13; \nvector<int> ans;\nvector<int> p[maxn],v[maxn],g[maxn];//拓扑排序建边 \nint t[maxn][26];//字典树\nstring s[maxn],ss[maxn];\nint mt[maxn],d[maxn]; \nint cnt=1;\nqueue<int> q;\nvoid insert(int rt,int k,int id){//字典序 \n\tif(id==s[k].size()){\n\t\tv[rt].push_back(k);\n\t\treturn;\n\t}\n\tif(s[k][id]=='_'){\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(!t[rt][i]) t[rt][i]=++cnt;\n\t\t\tinsert(t[rt][i],k,id+1);\n\t\t} \n\t}\n\telse{\n\t\tint vv=s[k][id]-'a';\n\t\tif(!t[rt][vv]) t[rt][vv]=++cnt;\n\t\tinsert(t[rt][vv],k,id+1);\n\t}\n}\nbool find(int id,string s){\n\tint rt=1;\n\tint yes=1;\n\tfor(int i=0;i<s.size();i++){\n\t\tint vv=s[i]-'a';\n\t\tif(t[rt][vv]){\n\t\t\trt=t[rt][vv];\n\t\t} \n\t\telse{\n\t\t\tyes=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tg[id]=v[rt];//寻找每个串可以匹配的模式串的集合\n\treturn yes; \n}\nint main()\n{\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> s[i];\n\t\tinsert(1,i,0);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tcin >> ss[i];\n\t\tscanf(\"%d\",&mt[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!find(i,ss[i])){\n\t\t\treturn printf(\"No\"),0;\n\t\t}\n\t}\n\tint fail=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint yes=0;\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(g[i][j]==mt[i]) yes=1;\n\t\t\telse{\n\t\t\t\tp[mt[i]].push_back(g[i][j]);\n\t\t\t\td[g[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tif(!yes){\n\t\tfail=1;\n\t\tbreak;}\n\t}\n\tif(fail) return printf(\"No\"),0;\n\t\n\tfor(int i=1;i<=n;i++){\n\t   if(!d[i]) q.push(i);\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tans.push_back(now);\n\t\tfor(int i=0;i<p[now].size();i++){\n\t\t\tint vv=p[now][i];\n\t\t\td[vv]--;\n\t\t\tif(!d[vv]){\n\t\t\t\tq.push(vv);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size()!=n) fail=1;\n\tif(fail) return printf(\"NO\"),0;\n\telse{\n\t\tprintf(\"YES\\n\");\n\t\tfor(int i=0;i<ans.size();i++) printf(\"%d \",ans[i]);\n\t}\n}\n```\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"gym-1st","url":"/2021/01/28/gym-1st/","content":"\n> 最近随便做了一场gym上的题，不得不说这题出的真的差，题目意思不清，样例不给解释还没有题解看……这里只想写一些有意思的题，有些题太无聊就不说了~\n\n## 2020 ICPC Gran Premio de Mexico 3ra Fecha\n\n<!-- more -->\n\n### C\n\n* 大致题意：由于涉及到了图片，实在说不清楚，放链接https://codeforces.com/gym/102890/problem/C\n* 题解：其实所谓三角形的个数，换种思路考虑就是选三角形的三条边，其实这题里就是选择底边和从斜边当中任取 $2$ 个，算一下组合数乘法原理乘起来即可。\n\n### E\n\n* 大致题意：有 $n$ 名员工，现在要给他们发工资，每个人业绩不同，第 $i$ 个人业绩为 $a_i$，规定，这 $n$ 个人坐成一圈时，一个人的业绩如果比相邻的人好，那么他得到的工资要更多，现在工资基数为 $k$ ，问如何分配才能使交出去的总工资最少。\n\n* 题解：其实模型还算比较简单，就是想起来不好想，规定假如两个相邻的数有大小关系则他们得到的权值也有相应的大小关系，如果要使得结果总和最小，那么最低权值一定是1，考虑到大小关系是一种逆序（垃圾离散数学，爬），可以用图来考虑，对于每个数 $i$ ，假如他比相邻的第 $j$ 个数大，则在 $i$ 向 $j$ 连接一条边，最后得到一个图，不难发现这张图上入度为 $0$ 的点，必定是最小的一批，有向路径上权值逐渐增大，之后经行拓扑排序即可，每次用陷入队的节点更新后入队的节点，更新答案。（这破题还卡输出格式，爪巴）\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  const int maxn=1e5+13;\n  vector<int> p[maxn];\n  int d[maxn];\n  int a[maxn],ans[maxn];\n  queue<int> q;\n  int main(){\n      int n,g;\n      scanf(\"%d%d\",&n,&g);\n      for(int i=1;i<=n;i++){\n      \tscanf(\"%d\",&a[i]);\n  \t}\n  \tfor(int i=1;i<=n;i++){\n  \t\tint nx=i%n+1;\n  \t\tif(a[nx]>a[i]) p[i].push_back(nx),d[nx]++;\n  \t\telse if(a[nx]<a[i]) p[nx].push_back(i),d[i]++;\n  \t}\n  \tfor(int i=1;i<=n;i++){\n  \t\tif(!d[i]) ans[i]=(!a[i]?0:1),q.push(i);\n  \t}\n  \twhile(!q.empty()){\n  \t\tint t=q.front();\n  \t\tq.pop();\n  \t\tfor(int i=0;i<p[t].size();i++){\n  \t\t\tint v=p[t][i];\n  \t\t\td[v]--;\n  \t\t\tif(d[v]==0){\n  \t\t\t\tans[v]=max(ans[v],ans[t]+1);\n  \t\t\t\tq.push(v);\n  \t\t\t}\n  \t\t}\n  \t}\n  \tfor(int i=1;i<=n;i++){\n  \tif(i<n) printf(\"%lld \",1ll*ans[i]*g);\n  \telse printf(\"%lld\",1ll*ans[i]*g); \n     }\n  } \n  ```\n\n  \n\n### G\n\n* 大致题意：有 $n$ 个金矿，每个金矿有三个数字，$a_i$，$l_i$，$r_i$，表示金矿的矿含量，以及在这个矿区采完矿后，之后必须在 $[i+l_i，i+r_i]$ 位置的矿区采矿，问最多能得到多少矿物。\n\n* 题解：考虑 $dp$ ，用 $dp[i]$ 表示**后面的矿区**对它产生的贡献，每个矿区 $i$ 产生的值可以对 $[i+l_i，i+r_i]$ 产生贡献，但是如果顺着考虑就会出现，不同的两个前面的矿区更新同一个后面的矿区造成错误，反过来考虑，可以考虑矿区 $i$ 可以接受来自 $[i+l_i，i+r_i]$ 的矿区的贡献，可以列出 $dp[i]=\\max_{j={l_i}}^{r_i}dp_{i+j}+a[i]$ ，这样每次只会跟新一个值，不会出现两种不同情况的值叠在一起的情况，区间取 $max$ 可以用线段树解决。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  typedef long long ll;\n  const int maxn=1e5+13;\n  ll dp[maxn<<2];\n  int g[maxn],l[maxn],r[maxn];\n  void up(int rt){\n  \tdp[rt]=max(dp[rt<<1],dp[rt<<1|1]);\n  }\n  void build(int rt,int l,int r){\n  \tif(l==r){\n  \t\tdp[rt]=g[l];\n  \t\treturn;\n  \t}\n  \tint mid=l+r>>1;\n  \tbuild(rt<<1,l,mid);\n  \tbuild(rt<<1|1,mid+1,r);\n  \tup(rt);\n  }\n  void modify(int rt,int l,int r,int x,ll now){\n  \tif(l==r){\n  \t\tdp[rt]=now;\n  \t\treturn;\n  \t}\n  \tint mid=l+r>>1;\n  \tif(x<=mid) modify(rt<<1,l,mid,x,now);\n  \telse modify(rt<<1|1,mid+1,r,x,now);\n  \tup(rt); \n  }\n  ll query(int rt,int l,int r,int LL,int rr){\n  \tif(LL>rr) return 0;\n  \tif(LL<=l&&rr>=r) return dp[rt];\n  \tint mid=l+r>>1;\n  \tll ans=0;\n  \tif(LL<=mid) ans=max(ans,query(rt<<1,l,mid,LL,rr));\n  \tif(rr>mid) ans=max(ans,query(rt<<1|1,mid+1,r,LL,rr));\n  \treturn ans;\n  }\n  int main()\n  {\n  \tint n;\n  \tscanf(\"%d\",&n);\n  \tfor(int i=1;i<=n;i++){\n  \t\tscanf(\"%d%d%d\",&g[i],&l[i],&r[i]);\n  \t}\n  \tbuild(1,1,n);\n  \tll ans=0;\n  \tfor(int i=n;i;i--){\n  \t\tint rr=min(i+r[i],n);\n  \t    ll add=query(1,1,n,l[i]+i,rr);\n  \t    ans=max(1ll*g[i]+add,ans);\n  \t    modify(1,1,n,i,1ll*g[i]+add);\n  \t}\n  \tprintf(\"%lld\",ans);\n   } \n  ```\n\n  \n\n### H\n\n* 大致题意：有 $n$ 道题，规定做第 $i$ 题能得到 $a_i$ 分，最后得到的分数为 $\\frac{做出来的分数总和}{所有题分数总和}$ ，现在要做满 $K$ 分，问最少要做多少道题，同时在得到题目数量之后，问有多少不同的题目组合满足最后能得到 $K$ 分以上，规定组合要按照字典序给出。\n* 题解：其实这是个签到题，但是一开始太不动脑筋直接dfs，导致最后字典序不好解决，其实先排序处理出最少要做的题目数量，然后直接状压枚举即可。（ $n$ 只有 $20$ ）\n\n### M\n\n* 大致题意：给定一个长度为 $n$ 的由数字 $0-9$ 组成的字符串，再给出 $9$ 个数字，表示数字$i$ 需要被从数组中删掉 $a_i$次，问删掉所有要删的数之后能得到的最大的数是多少？\n* 题解：对于任何数来说，肯定原本在后面的，而且比前面某些可以被删掉的数大的数放的越前面越优秀，所以可以考虑用单调栈的模型来处理，预处理出每个数的数量的前缀和，每一步都维护剩余的个数和剩余未被删的个数，考虑每次入栈的数如果比栈顶的数大，而且栈顶的数还有被删的余地，那么就删去栈顶的元素，如果入栈的数不得不删掉，那么直接删掉，处理结束后栈中的数就是答案。\n\n```c++\n#include <bits/stdc++.h>//单调栈 \nusing namespace std;\nconst int maxn=1e5+13;\nchar s[maxn];\nint st[maxn];\nint num[maxn],del[maxn];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=9;i++) scanf(\"%d\",&del[i]);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tnum[s[i]-'0']++;\n\t}\n\tint top=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint now=s[i]-'0';\n\t\tif(num[now]==del[now]){//如果需要删掉的等于剩下的那么全部删掉 \n\t\t\tnum[now]--;\n\t\t\tdel[now]--;\n\t\t\tcontinue;\n\t\t}\n\t\twhile(top&&now>st[top]&&del[st[top]]){//单调栈策略，让高位数往前放 \n\t\t\tdel[st[top]]--;\n\t\t\ttop--;\n\t\t}\n\t\tst[++top]=now;\n\t\tnum[now]--;\n\t}\n\tfor(int i=1;i<=top;i++) printf(\"%d\",st[i]);\n } \n```\n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"做题记录1.27","url":"/2021/01/27/做题记录1-27/","content":"\n> 最近做了好久鸽子啊，还是太摸了，成绩再差也不能自暴自弃啊喂，要做一个爱学习的肥宅~\n\n## Atcoder beginner round 189\n\n<!-- more -->\n\n### B\n\n* 大致题意：设定一个人酒量为固定值$K$,这个人喝下超过这个量的酒就会醉，现在有$n$瓶酒，每瓶酒容量为$V$，酒精含量为百分之$P$,问这个人喝到第几瓶酒的时候会醉，或者根本不会醉？\n\n* 题解：为啥要给~~弱智题~~写题解？因为这是~~坑人题~~，计算的时候要现乘上100，不然$double$精度会出很大问题……能不用double的题尽量别用，这种类型的数也太容易出问题了……\n\n### D\n\n* 大致题意：给定一个数$n$，和$n$个字符，字符为**OR**和**AND**，其实就是逻辑运算符号，现在要在这n个逻辑运算符号产生的$n+1$的空位上插入$0$或者$1$，问有多少种可能使结果为$1$。\n\n* 题解：这题思路还是很巧妙的，可以采用递推的思想，设 $dp[i][1]$ 和 $dp[i][0]$ 分别为 $i$ 个符号后结果为 $1$ 和结果为 0 的情况总数，那么很容易列出递推式子。\n\n  * 如果第 $i$ 个符号是且，那么有：\n\n    $dp[i][1] = dp[i-1][1]$\n\n    $dp[i][0] = 2*dp[i-1][0]+dp[i-1][1]$\n\n  * 如果第 $i$ 个符号是或，那么有：\n\n    $dp[i][1] = dp[i-1][1]*2+dp[i-1][0]$\n\n    $dp[i][0] = dp[i-1][1]$\n\n  $O(n)$遍历即可。\n\n### E\n\n* 大致题意：有n个坐标点，现在依次对这 $n$ 个坐标点做 $m$ 个操作，这些操作有四种情况，第一种情况为顺时针旋转点，第二种为逆时针旋转点，第三种为将点按 $x=p$ 做对称，第四种为将点按照 $y=p$ 做对称，还有q组询问，每次询问点 $b$ 在 $a$ 次操作后的点为什么。\n\n* 题解：高代题~，这些操作每个都可以用矩阵表示，然后几次操作的总和便可以直接用矩阵的乘积来表示，所以只需要维护矩阵的前缀乘积即可。值得注意的是，原本旋转矩阵的模式是二维的，但是这里显然无法实现对称操作，发现对称操作实际就是把点$(x,y)$转变为$(2p-x,y)$或者$(x,2p-y)$，所以可以维护三维列向量，和三维变换矩阵。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  typedef long long ll;\n  const int maxn=2e5+13;\n  ll x[maxn],y[maxn];\n  struct M{\n     ll a[6][6];\n  };\n  M cr,ccr,xp,yp,mult;\n  M p[maxn];//操作矩阵 \n  M mul(M A,M B){\n     M C;\n     for(int i=1;i<=3;i++){\n     \tfor(int j=1;j<=3;j++) C.a[i][j]=0;\n     }\n     for(int i=1;i<=3;i++){\n     \tfor(int j=1;j<=3;j++){\n     \t\tfor(int z=1;z<=3;z++){\n     \t\t\tC.a[i][j]+=A.a[i][z]*B.a[z][j];\n  \t\t   }\n  \t   }\n     }\n     return C;\t\n  }\n  int main()\n  {\n      ccr.a[1][2]=-1;\n  \tccr.a[2][1]=ccr.a[3][3]=1;\n  \tcr.a[1][2]=cr.a[3][3]=1;\n  \tcr.a[2][1]=-1;\n  \txp.a[1][1]=-1;\n  \txp.a[2][2]=xp.a[3][3]=1;\n  \typ.a[1][1]=yp.a[3][3]=1;\n  \typ.a[2][2]=-1;\n  \tfor(int i=1;i<=3;i++){\n  \t\tfor(int j=1;j<=3;j++){\n  \t\t\tif(i==j) mult.a[i][j]=1;\n  \t\t\telse mult.a[i][j]=0;\n  \t\t}\n  \t}\n  \tint n;\n  \tscanf(\"%d\",&n);\n  \tfor(int i=1;i<=n;i++){\n  \t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n  \t}\t\n  \tint m;\n  \tscanf(\"%d\",&m);\n  \tp[0]=mult;\n  \tfor(int i=1;i<=m;i++){\n  \t\tint op;\n  \t\tscanf(\"%d\",&op);\n  \t\tif(op==1) p[i]=mul(cr,p[i-1]);\n  \t\telse if(op==2) p[i]=mul(ccr,p[i-1]);\n  \t\telse if(op==3){\n  \t\t\tint ad;\n  \t\t    scanf(\"%d\",&ad);\n  \t\t    xp.a[1][3]=2*ad;\n  \t\t    p[i]=mul(xp,p[i-1]);\n  \t\t}\n  \t\telse{\n  \t\t\tint ad;\n  \t\t\tscanf(\"%d\",&ad);\n  \t\t\typ.a[2][3]=2*ad;\n  \t\t\tp[i]=mul(yp,p[i-1]);\n  \t\t}\n  \t}\n  \tint q;\n  \tscanf(\"%d\",&q);\n  \twhile(q--){\n  \t\tint a,b;\n  \t\tscanf(\"%d%d\",&a,&b);\n  \t\tll nx,ny;\n  \t\tnx=p[a].a[1][1]*x[b]+p[a].a[1][2]*y[b]+p[a].a[1][3];\n  \t\tny=p[a].a[2][1]*x[b]+p[a].a[2][2]*y[b]+p[a].a[2][3];\n  \t\tprintf(\"%lld %lld\\n\",nx,ny);\n  \t}\n   } \n  ```\n\n  \n\n### F\n\n* 大致题意：一个人要从 $0$ 坐标点走到 $n$ 坐标点，规定一次移动可以向前移 $1-m$ 个位置，移动多少都是等概率的。有 $k$ 个位置，一旦移动到这 $k$ 个位置种任意一个，都会返回 $0$ 坐标点，问从 $0$ 移动到 $n$ 的期望步数。\n\n* 题解：其实就是一个概率dp，首先用$f[i]$ 表示从 $i$ 出发走到 $n$ 的期望步数，那么就可以列出递推式：\n\n  $$\n  f[i]=\n  \\begin {cases} \n  0 ,&i\\ge n \\\\ \n  f[0],&i \\in K \\\\ \n  \\frac{\\sum_{j=1}^{m}f[i+j]}{m}+1,& i\\notin K \\\\\n  \\end{cases}\n  $$\n  其实仔细观察这个式子会发现，其实所有$f[i]$ 都可以用 $f[0]$ 来表示，包括 $f[0]$ ,$f[0]=f[0]*k+b$ 所以最后可以得到关于 $f[0]$ 的一个一次方程，就可以把$f[0]$ 解出来，之后从后往前dp即可，用 $dp[i][0]$ 和 $dp[i][1]$ 表示 $k$ 和 $b$ 的值，在dp过程中同时维护一下 $k$ 和 $b$ 的前缀和即可。\n  \n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  double eps=1e-6;\n  const int maxn=2e5+13;\n  double dp[maxn][2];\n  double sum[maxn][2];\n  int tag[maxn];\n  int main()\n  {\n  \tint n,m,k;\n  \tscanf(\"%d%d%d\",&n,&m,&k);\n  \tfor(int i=1;i<=k;i++){\n  \t\tint t;\n  \t\tscanf(\"%d\",&t);\n  \t\ttag[t]=1;\n  \t}\n  \tdp[n][0]=dp[n][1]=0;\n  \tfor(int i=n-1;~i;i--){\n  \t\tif(tag[i]){\n  \t\t\tdp[i][0]=1;\n  \t\t\tdp[i][1]=0;\n  \t\t}\n  \t\telse{\n  \t\t\tdp[i][0]=(sum[i+1][0]-sum[i+m+1][0])/m;\n  \t\t\tdp[i][1]=(sum[i+1][1]-sum[i+m+1][1])/m+1.0;\n  \t\t}\n  \t\tsum[i][0]=sum[i+1][0]+dp[i][0];\n  \t\tsum[i][1]=sum[i+1][1]+dp[i][1];\n  \t}\n  \tif(fabs(1.0-dp[0][0])<eps) printf(\"-1\");\n  \telse printf(\"%.4lf\",dp[0][1]/(1.0-dp[0][0]));\n  }\n  ```\n  \n   \n  \n  ","tags":["atcoder"],"categories":["算法","刷题"]},{"title":"做题记录1.21","url":"/2021/01/21/做题记录1-21/","content":"\n## codeforces round 696(div 2)\n\n<!-- more -->\n\n### C\n\n* 大致题意：数组$a$中有$2n$个数,下面进行如下操作，一开始选出一个数$x$ ,从数组$a$中选出两个数，使这两个数的和等于$x$，然后去掉这两个数，将两个数中较大的数作为新的$x$,重复上述操作，判断是否可以通过上述操作，将一个数组中的数清空。\n* 题解：乍一看确实无从下手，但是仔细一想会发现，这些数都是正数，那么一开始选择的那个较大的数一定是整个数组最大的数，如果不是这样，那么之后产生的最大值只会比数组的最大值小，数组中的最大值就永远不会消去。所以，只需要枚举第一次选的数即可，每次操作结束后，同理，下一次操作也必定需要选择剩余的数的最大值，另外一个数可以通过上一个最大值减这个最大值的得到，由于每一步都是限定死的，所以一步无法完成则结果一定是no，如果每步都能完成一定是唯一解。\n\n### D\n\n* 给定一个数组$a$，每次可以选择两个相邻的数，将每个数减1，问是否能通过这样的操作将数组$a$清空，如果给定数组不行，那么是否可以通过交换相邻两个数，使以上条件成立。\n\n* 题解：这题真的麻烦，不过也真的很巧妙。不妨先考虑边界情况，如果第一个数能全部被消除掉，那么第二个数一定要比第一个大，第三个数要比消掉第一个数后的第二个数大。所以定义数组$b_i$ ,表示消除上一个数后还剩多少，显然 $b_i=a_i-b_{i-1}$ ，如果要条件成立，那么必须要 $b_i\\geq0$ 且 $b_n =0 $ 。下面考虑交换数对$b_i$的影响，枚举几项后会发现，如果$i$和$i+1$ 交换对之前无影响，对之后的与$i$同奇偶的位置影响相同（加$2*(a_i-a_{i+1})$），不同奇偶的位置也有相同的影响（加$2*(a_{i+1}-a_i)$）。之后从后往前枚举交换位置$i$，累计从后往前与i同奇偶位置最小值和不同奇偶位置最小值，每次检验这两个位置操作后是否满足大于等于0即可。注意$i$ 位置的情况需要特判。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  typedef long long ll;\n  const int maxn=2e5+13;\n  int a[maxn];\n  ll b[maxn],c[maxn];\n  ll dp[maxn];//从后往前找的最小值 \n  int main()\n  {\n  \tint t;\n  \tscanf(\"%d\",&t);\n  \twhile(t--){\n  \t\tint n;\n  \t\tscanf(\"%d\",&n);\n  \t\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n  \t\tc[0]=1e18;\n  \t\tfor(int i=1;i<=n;i++) b[i]=a[i]-b[i-1],c[i]=min(c[i-1],b[i]);\n  \t\tif(c[n]>=0&&b[n]==0){\n  \t\t\tprintf(\"YES\\n\");\n  \t\t\tcontinue;\n  \t\t}\n  \t\tint yes=0;\n  \t\tdp[0]=dp[1]=1e18;\n  \t\tfor(int i=n-1;i;i--){\n  \t\t\tint k=(n-i)&1;\n  \t\t\tif(b[n]+1ll*(a[i]-a[i+1])*(k?2:-2)!=0||c[i-1]<0){\n  \t\t\tdp[k]=min(dp[k],1ll*b[i]);\n  \t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif(dp[0]+1ll*(a[i]-a[i+1])*(k?2:-2)>=0&&dp[1]+1ll*(a[i]-a[i+1])*(k?-2:2)>=0&&1ll*b[i]-a[i]+a[i+1]>=0){\n  \t\t\t\tyes=1;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tdp[k]=min(dp[k],1ll*b[i]);\n  \t\t}\n  \t\tif(yes) printf(\"YES\\n\");\n  \t\telse printf(\"NO\\n\");\n  \t}\n   } \n  ```\n\n### E\n\n* 大致题意：定义一排列中，一次操作，将位置 $i$ 和位置 $j$ 上的数互换，必须满足条件 $p_j=i$ ，一次这样的操作的代价为$(j-i)^2$ ，问构造一个这样排列，以及一系列上述操作将这个排列变成满足 $p_i=i$ 的排列，且需要的代价最高。\n\n* 题解：这个构造tql，太难想了。不难发现，其实上述过程就是每次使一个数回归原位，所以最多只能有$n$次操作，不妨从结果往前推，从一个已经排好的数组推，首先首尾互换，之后每次将下一个数移到另一边的最后一个位置，也就是将 $2$ 移到 $n$ ,将 $n-1$ 移到 1，将 3 移到 $n$ 以此类推……这样最后的代价是 \n  \n  ​                                                   $\\sum_{\\frac{n+1}{2}}^{n-1} 2*(i-1)^2+(n-1)^2$\n  \n  奇数情况还要单独减去 $(\\frac{n}{2})^2$ ，可以证明这样一定是最大的，操作用 $vector$ 保存后倒序输出即可。\n\n ","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"做题记录1.20","url":"/2021/01/20/做题记录1-20/","content":"\n## codeforces round 695\n\n<!-- more -->\n\n### B\n\n* 大致题意：給一串数，定义两种情况，一种是“山峰”，也就是一个数旁边两个数都比它小，还有一种是“山谷”，也就是一个数旁边两个数都比他大。现在可以随意将一个数改成任意一个数，问改完后“山峰”和“山谷”总合的最小的可能是多少？\n* 题解：枚举几种情况后会发现，如果要对一个数经行修改，将其变成恰好等于左边的数，或者恰好等于右边的数情况一定是最优的，因为相等关系既不会产生“山峰”，也不会产生“山谷”。一次改变会改变三个数的情况，减掉再处理新的情况的答案即可，可以在O(n)的复杂度内枚举遍历。\n\n### C\n\n* 大致题意：有三个集合，每个集合中装有不同数量的数，每次可以从两个集合中取出两个数a，b，将b从原集合中去掉，用a-b来替换原集合中的a，进行上述操作直到集合中只剩下一个数，问最后剩下的数最大可能是多少。\n\n* 题解：可以发现，实际上处理的过程就是给所有数赋予正负号，由于所有数都是正的，只要保证产生足够多的正号即可。经过枚举（看题解 x）发现只有两种可能：\n\n  * 一个集合中的数全部变负，来保证另外两个集合的数都是正的，实现方法就是用选定的集合的数减其他集合的数，最后剩一个数再去减选定集合中的数即可。\n  * 在两个集合中选定两个数变负（最小），其余全正，这个很好实现。\n\n  之后两种情况分别计算最大再取max即可。\n\n### D\n\n* 大致题意：给了一串数a，规定一种操作：向左移动一格或者向右移动一格，这样的操作每次都能组成一条路径，问数组a上所有可能路径的路径和的总和为多少，路径和定义为路径中经过的点的权值和。还有q组询问，每次改变数组a的一个位置上的权值，对于每次询问要输出目前的答案为多少，对$1e9+7$取模。\n* 题解：其实这题后面的多组询问纯属吓唬人行为……，其实可以预处理出所有可能路径中每个数都会经过多少次，这样修改的处理就很好做。首先可以用dp处理出第i步到达j一共有多少可能的路径，方程很简单就是 $dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1]$ ，后对于每个数只要枚举经过它的所有路径即可，会发现，如果第i步到了这个点，那么剩下的$k-i$步的走向也会产生不同的路径，其实从$j$点出发走$k-i$的总路径数其实是和走$k-i$步到达$j$的路径数是相同的，发过来就能一一对应了，所以有乘法原理，$i$步后到达$j$的总路径数为$ dp[i][j]*dp[k-i][j]$ ，之后枚举次数和时间累加即可。\n\n### E\n\n* 大致题意：有一颗树，树上每个点都有一个权值，找出所有满足从他出发到所有点的路径上都没有重复的权值的点，即对于那个点到每个一点的路径上，都不会有重复的数出现。\n\n* 题解：这题的方法确实很强……，膜拜题解。首先可以发现两件事，如果一个点的父节点子树中存在与这个点权值相同的点，则这个点的子树中的点都不符合题意，如果一个节点儿子节点的子树中存在与这个点权值相同的点，则除该儿子节点的子树外所有点都不符合题意。可以发现每次都是对一个子树经行操作，所以可以直接采用树上差分的方法，+1表示标记不符合情况的点，对于第二种情况，可以先对整体+1，再对子树减1，dfs差分处理后值为0的点便是符合题意的点。权值比较大，所以要先离散化……。\n\n  ```c++\n  #include <bits/stdc++.h>\n  using namespace std;\n  const int maxn=2e5+13;\n  int sz[maxn];\n  int a[maxn],f[maxn],b[maxn];\n  vector<int> p[maxn];\n  int cnt[maxn];\n  int dfn[maxn];\n  int tot[maxn];\n  int pp;\n  void dfs(int rt,int fa){\n  \tdfn[rt]=++pp;\n  \tsz[rt]=1;\n  \tint tp=cnt[b[rt]];\n  \tcnt[b[rt]]++;\n  \tfor(int i=0;i<p[rt].size();i++){\n  \t\tint v=p[rt][i];\n  \t\tint tmp=cnt[b[rt]];\n  \t\tif(v==fa) continue;\n  \t\tdfs(v,rt);\n  \t\tsz[rt]+=sz[v];\n  \t\tif(cnt[b[rt]]>tmp){\n  \t\t\tf[1]++;\n  \t\t\tf[dfn[v]]--;\n  \t\t\tf[dfn[v]+sz[v]]++;\n  \t\t}\n  \t}\n  \tint res=tot[b[rt]]-(cnt[b[rt]]-tp);\n  \tif(res>0){\n  \t\tf[dfn[rt]]++;\n  \t\tf[dfn[rt]+sz[rt]]--;\n  \t}\n  }\n  int main()\n  {\n  \tint n;\n  \tscanf(\"%d\",&n);\n  \tfor(int i=1;i<=n;i++){\n  \t\tscanf(\"%d\",&a[i]);\n  \t\tb[i]=a[i];\n  \t}\n  \tfor(int i=1;i<=n-1;i++){\n  \t\tint u,v;\n  \t\tscanf(\"%d%d\",&u,&v);\n  \t\tp[u].push_back(v);\n  \t\tp[v].push_back(u);\n  \t}\n  \tsort(a+1,a+1+n);\n  \tint len=unique(a+1,a+1+n)-a-1;\n  \tfor(int i=1;i<=n;i++){\n  \t\tb[i]=lower_bound(a+1,a+1+len,b[i])-a;\n  \t\ttot[b[i]]++;\n  \t}\n  \tdfs(1,0);\n  \tfor(int i=1;i<=n;i++){\n  \t\tf[i]=f[i]+f[i-1];\n  \t}\n  \tint ans=0;\n  \tfor(int i=1;i<=n;i++){\n  \t\tif(!f[i]) ans++;\n  \t}\n  \tprintf(\"%d\",ans);\n  }\n  ```\n\n  \n\n","tags":["codeforces"],"categories":["算法","刷题"]},{"title":"网络瘤","url":"/2021/01/19/网络瘤/","content":"\n# 网络流\n\n~模板略啦，这里只想整理一下平时遇到的一些问题。\n\n<!-- more -->\n\n## 常见模型\n\n### 最大权闭合子图\n\n#### 模型：\n\n给定一个n阶图，每个点都有一个权值，这个图中的点存在一些关联，现在要从图中取一些点，规定选一个点的同时也要选另外的一些点，问如何选能使被选数的权值和最大。\n\n#### 解法：\n\n首先建立源点s和汇点t，从源点向所有权值为正的点连一条等于权值的边，所有权值为负的点向汇点连一条等于权值绝对值的边，所有有关联的点之间连一条权值为无限大的边，之后跑最小割，答案即为所有正权值之和减去最小割。\n\n#### 正确性解释：\n\n首先，关联点之间边权无限大保证了关联点之间的边不会被割断，被割断的只有与源点和汇点连的边，这就相当于对点进行选择，现在规定被割掉的边连的正权点为不被选的点，被割掉的负权点为被选的点，那么结果 = 所有正权点点权和 - 最小割 = 所有正权点点权和 - （不选的正权点+被选的负权点之和的绝对值）= 被选的正权权点 - 被选的负权点之和的绝对值。 也就是想要的答案。\n\n实际上，由于流量是从正权点出去的，如果正全点被割断了，负权点未被割断，说明之后的负权点的权值过大，这时不选这个正权点更优。同理，负点权被割断，说明之前的正点权过大，选那个正点，总体减去负点权的绝对值更优。所以这样子做是可以得到最优解滴~。","tags":["网络流"],"categories":["算法","算法整理"]},{"title":"做题记录1.18","url":"/2021/01/18/做题记录1-18/","content":"\n## codeforces educational round 102\n\n<!-- more -->\n\n### D \n\n* 大致题意: 存在n个操作，这n个操作只有两种，一种是将数+1，还有一种是将数-1，现在数初始值为0，存在m个询问，每个询问将 l 到 r 的操作取消，问不执行 l 到 r 的操作最后得到的结果是什么。\n\n* 题解：此题本质上是求前缀和最大值和最小值，一开始想莽线段树，后来想想码量实在太大（其实是懒）。后来发现其实我想偏了，其实只要求出前缀和的前缀最大值和前缀最小值即可，对于消除区间之后的部分，将消除的部分的和减去即可，由于是整体减，实际上不产生影响。O(n)预处理后，对于每个区间，O(1) 计算前后两部分的最小值和最大值即可。\n\n### E\n\n* 大致题意：有一个边带权无向图，询问对于每一个点k，点1到点k的所有路径中，$\\sum_{i=1}^{k}w_{e_i}-\\max_{i=1}^kw_{w_i}+\\min_{i=1}^kw_{e_i}$ 的最小值。\n* 题解：实际上求出这个数的过程可以看作将一个边算两次，将一个边不计算在内。可以设一个三维数组，dis[maxn]\\[2][2]，第一维用于表示每个点，剩下两维用于表示是否已经将一条边算了两次，是否已经不算了一条边，之后仿照dij的写法转移便可以了，dij的性质保证了每个数都是正确的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2e5+13;\nvector<pair<int,ll>> p[maxn];\nstruct node{\n\tll dis;\n\tint i,j,k;\n};\nbool operator <(node a,node b){\n\treturn a.dis>b.dis;\n}\npriority_queue<node> q;\nll dis[maxn][2][2];\nint vis[maxn][2][2];\nvoid dij()\n{\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[1][0][0]=0;\n\tq.push(node{dis[1][0][0],1,0,0});\n\twhile(!q.empty()){\n\t\tnode now=q.top();\n\t\tll d=now.dis;\n\t\tint i=now.i,j=now.j,k=now.k;\n\t\tq.pop(); \n\t\tif(vis[i][j][k]) continue;\n\t\tvis[i][j][k]=1;\n\t\tfor(int t=0;t<p[i].size();t++)\n\t\t{\n\t\t\tint v=p[i][t].first;\n\t\t\tll ad=p[i][t].second;\n\t\t\tif(dis[v][j][k]>d+ad){\n\t\t\t\tdis[v][j][k]=1ll*d+ad;\n\t\t\t\tq.push(node{dis[v][j][k],v,j,k});\n\t\t\t}\n\t\t\tif(j==0&&dis[v][1][k]>d+2*ad){\n\t\t\t\tdis[v][1][k]=d+2*ad;\n\t\t\t\tq.push(node{dis[v][1][k],v,1,k});\n\t\t\t}\n\t\t\tif(k==0&&dis[v][j][1]>d){\n\t\t\t\tdis[v][j][1]=d;\n\t\t\t\tq.push(node{dis[v][j][1],v,j,1});\n\t\t\t}\n\t\t\tif(j==0&&k==0&&dis[v][1][1]>d+ad){\n\t\t\t\tdis[v][1][1]=d+ad;\n\t\t\t\tq.push(node{dis[v][1][1],v,1,1}); \n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint n,m,u,v;\n\tll w;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d%lld\",&u,&v,&w);\n\t\tp[u].push_back({v,w});\n\t\tp[v].push_back({u,w});\n\t}\n\tdij();\n\tfor(int i=2;i<=n;i++) printf(\"%lld \",dis[i][1][1]);\n}\n```\n\n### F \n\n* 大致题意：给定两个集合a和b，集合a中，第i个数，权值为$b_i$ ，现在要从集合a中取数，规定，如果$a_i$被取走，那么a集合中所有整除$a_i$的数也要被取走，问最后的权值最大可能是多少，a和b的数量的范围都是3000。\n* 题解：这是一个最大权闭合子图的模板题，建立源点s和汇点t，源点向所有权值为正的数连一条权值为$b_i$的边，所有权值为负的点向汇点连一条权值为$|b_i|$ 的边，存在整除关系的点连一条权值inf的边，然后跑最小割，结果即为正边权之和减去最小割。值得注意 的是，这题对空间有特殊限制，所以不能无脑见图连边，（会被全是1的数据卡掉）对于每个点，其实对于一个数，只要连一次即可，连边顺序控制为从右向左，就能保证最后相互整除关系的点之间都是联通的。","tags":["codeforces"],"categories":["算法","刷题"]}]